<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Модули :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
  <a href="./12_proxies_and_reflection.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./appendix_A.html" title="next chapter">▶</a>
</nav>
	 <header id="header" class="">
	 	<h1><div class="head-num">Глава 13</div>Модули</h1>
	 	<p>Един от най-податливите и объркващи аспекти на JavaScript отдавна е  “сподели всичко” подхода към зареждане на код. Докато другите езици имат понятия, като пакети, JavaScript изостава и всичко дефинирано във всеки файл споделя същия глобален обхват. Тъй като уеб приложенията стават по-сложни и размера на използване на JavaScript нараства, подхода “сподели всичко” започва да показва проблеми със сблъсъци в именуването, сигурността и др. Една от целите на ECMAScript 6 е да реши този проблем и да внесе някакъв ред в JavaScript приложенията. Това е когато модула влиза.</p>
	 </header><!-- /header -->
	 <article>
	 	<h3>Какво е модули?</h3>
	 	<p><em>Modules</em> са JavaScript файлове, които се зареждат в специален режим (за разлика от <em>scripts</em>, които се зареждат по оригинален начин в  JavaScript). По време на моето писане, нито браузърите, нито  Node.js имат свой начин да зареждат ECMAScript 6 модули, но и двата са посочили, че ще трябва да бъде някакъв вид от опции за да го направят. Причината тези опции да са необходими е така, защото модул файловете имат много различна семантика от не-модул файловете.</p>
	 	<dl>
	 		<dd>
	 			<ol>
	 				<li>Модул кода автоматично минава в строг режим и няма начин да се откажете от <em>strict mode</em>.</li>
	 				<li>Променливи, създадени в най-горното ниво на модула не се добавят автоматично към споделения глобален обхват. Те съществуват само в рамките на обхвата на модула на най-високо ниво.</li>
	 				<li>Стойността на <em>this</em> в най-горното ниво на модула е <em>undefined</em>.</li>
	 				<li>Модулите не позволяват HTML-стил на коментарите в рамките на кода(останала особеност от ранните дни на браузъра).</li>
	 				<li>Модулите трябва да <em>export</em> (изнасят) всичко, което трябва да бъде на разположение на кода извън модула.</li>
	 			</ol>
	 		</dd>
	 	</dl>
	 	<p>Тези различия може да изглеждат дребни на пръв поглед, обаче, те представляват значителна промяна в начина, по който JavaScript кода се зарежа и оценява.</p>
	 	<p>Модул файловете в JavaScript са създадени, точно както всеки друг файл в JavaScript: в текстов редактор и обикновено с  .js разширение. Единствената разлика по време на развитието е, че можете да използвате малко по-различен синтаксис.</p>
	 	<h3>Основен износ и внос</h3>
	 	<p>Ключовата дума <em>export</em> се използва да изложи части от публикуван код към други модули. В най-простия случай, можем да поставим <em>export</em> пред всяка променлива, функция или клас декларация за да ги изнесем от модула. Например:</p>
	 	<dl>
	 		<dd><pre class="highlight">
// export data
<span class="code">export var</span> color = "red";
<span class="code">export let</span> name = "Nicholas";
<span class="code">export const</span> magicNumber = 7;

// export function
<span class="code">export function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num1;
}

// export class
<span class="code">export class</span> Rectangle {
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="comment"><em>// тази функция е частна за модула</em></span>
<span class="code">function</span> subtract(num1, num2) {
    <span class="code">return</span> num1 - num2;
}

<span class="comment"><em>// дефиниране на функция</em></span>
<span class="code">function</span> multiply(num1, num2) {
    <span class="code">return</span> num1 * num2;
}

// export later
<span class="code">export</span> multiply;
	 		</pre></dd>
	 	</dl>
	 	<p>Има няколко неща, които могат да се забележат в този пример:</p>
	 	<dl>
	 		<dd>
	 			<ol>
	 				<li>Всяка декларация е точно същата, както би била в противен случай без ключовата дума <em>export</em>.</li>
	 				<li>Двете функции и клас декларацията изискват име. Не можем да изнасяме анонимни функции или класове, използващи този синтаксис (освен ако не се използва ключовата дума <em>default</em>, обсъдена по-късно в тази глава)</li>
	 				<li>Не е необходимо винаги да се изнася декларация, може също да се изнасят референции, както с примера <em>multiply</em>.</li>
	 				<li>Всички променливи, функции или класове, които не са изрично изнесени, остават скрити от модула. В този пример, <em>subtract()</em> не се изнася и следователно не е достъпна от външната страна на модула.</li>
	 			</ol>
	 		</dd>
	 	</dl>
	 	<p>Важно ограничение на <em>export</em> е, че трябва да се използва в най-високо ниво на модула. Например, това е синтактична грешка:</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">if</span> (flag) {
    <span class="code">export</span> flag;    // syntax error
}
	 		</pre></dd>
	 	</dl>
	 	<p>Този пример е синтактична грешка, защото <em>export</em> е вътре в <em>if</em> изявлението. <em>Exports</em> не може да бъде в условие или направен динамично по никакъв начин. Част от ползата от модул синтаксиса е, че JavaScript машината може статично да определи, какво да бъде изнесено. Като такъв можете да използвате <em>export</em> само на най-високото ниво на модула.</p>
	 	<dl>
	 		<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Ако използвате <em>transpiler</em> като <em>Babel.js</em>, може да откриете, че <em>export</em> може да се използва на всякъде. Това работи само, когато кода се конвертира в ECMAScript 5 и няма да работи с реална модулна система на ECMAScript 6.</strong></dd>
	 	</dl>
	 	<p>След като имаме модул с износ, можем да получим достъп до функционалноста в друг модул, с помощта на ключовата дума <em>import</em> (внос).  Едно внос изявление има две части: идентификатори за внос и модула, който следва да се внесе от тези идентификатори. Основната форма е, както следва:</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">import</span> { identifier1, identifier2 } from "module";	 			
	 		</pre></dd>
	 	</dl>
	 	<p>Фигурните скоби след <em>import</em> показват идентификаторите за внос от даден модул. Ключовата дума <em>from</em> се използва за обозначаване на модула, от който идентификаротите да внасят. Модулът е определен с помощта на <em>string</em>. По време на моето писане, все още се колебаят как да изглеждат идентификаторите на модула. Те могат да останат пълни файлови пътища (като “../mymodule.js”), файлови пътища без разширение (като “../mymodule”) или нещо друго. Това вероятно няма да бъде определено преди браузърите и Node.js да започнат да прилагат модулите.</p>
	 	<dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Въпреки че изглежда подобно, списъкът с идентификаторите за импортиране не е <em>destuctiring</em> (разграден) обект.</strong></dd>
	 	</dl>
	 	<p>При вноса на идентификатор от един модул, идентификаторът действа, все едно, че е определен с <em>const</em>. Това означава, че не може да се дефинира друга променлива със същото име, използване на идентрификатор  преди <em>import</em> изявлението или изменение на стойността му.</p>
	 	<p>Да предположим, че първият пример в този раздел е в модул, наречен "example". Можем да внесем и използваме идентификатори от този модул по редица начини. Можем просто да импортираме един идентификатор:</p>
	 	<dl>
	 		<dd><pre class="highlight">
// import just one
<span class="code">import</span> { sum } from "example";

console.log(sum(1, 2));     // 3

sum = 1;        // error
	 		</pre></dd>
	 	</dl>
	 	<p>Този пример внася само <em>sum()</em> от <em>example</em> модула. Въпреки че, <em>example</em> модула изнася повече от една функция, те не са изложени тука. Ако се опитаме да зададем нова стойност на <em>sum</em>, резултата е грешка, тъй като не можем да присвояваме на импортираните идентификатори.</p>
	 	<p>Ако искаме да импортиране няколко идентификатори от <em>example</em> модула, можем изрично да ги изброим:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
// import multiple
<span class="code">import</span> { sum, multiply, magicNumber } from "example";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, три идентификатора се внасят от <em>example</em> модула: <em>sum, multiply</em> и <em>magicNumber</em>. След това се използват, все едно са дефинирани на място.</p>
	 	<p>Има също така и специален случай, който позволява да импортираме целия модул, като обект. Всичко от износа след това е на разположение в този обект, като свойства. Например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
// import everything
<span class="code">import</span>* as example from "example";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>В този код, <em>example</em> модула е зареден изцяло в един обект наречен <em>example</em>. Изнесените имена <em>sum(), multiple()</em> и <em>magicNumber</em> след това са достъпни, като свойства на <em>example</em>.</p>
	 	<p>Имайте в предвид, че кода вътре в един модул се изпълнява само веднъж, независимо от това колко пъти той ще се използва в <em>import</em> изявлението. Помислете върху следното:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { sum } from "example";
<span class="code">import</span> { multiply } from "example";
<span class="code">import</span> { magicNumber } from "example";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Въпреки, че има три <em>import</em> изявления в този модул, кодът в "example" ще бъде изпълнен само веднъж. Инстанцията на модула се съхранява в паметта и се използва повторно, когато друго <em>import</em> изявление е препратка към него. Няма значение, ако <em>import</em> изявленията са в модула или са разпръснати в няколко модула - всяко от тях ще използва същата инстанция на модула.</p>
	 	<h3>Преименуване на износа и вноса</h3>
	 	<p>Понякога оригиналното име на променлива, функция или клас не е това, което искаме да използваме. Възможно е да се смени името на износа, както по време на износа и когато идентификатора се внася.</p>
	 	<p>В първия случай, да предположим, че имаме функция, която искаме да изнасяме с друго име. Можем да използваме, ключовата дума <em>as</em> за да зададем името на функцията, което трябва да се знае извън модула:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num2;
}

<span class="code">export</span> { sum as add };
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, функцията <em>sum()(sum е local name)</em> се изнася, като <em>add()(add е exported name)</em>. Това означава, че ако друг модул иска да внася тази функция, ще трябва да използва името <em>add</em>:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { add } from "example";	 				
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Ако внасящия модул на функцията иска да използва друго име, той също може да използва <em>as</em>:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { add as sum } from "example";
console.log(<span class="code">typeof</span> add);            // "undefined"
console.log(sum(1, 2));             // 3
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Този код внася <em>add()</em> функцията (<em>import name</em>) и го преименува на <em>sum() (local name)</em>. Това означава, че няма идентификатор, с име <em>add</em> в този модул.</p>
	 	<div class="aside">
	 	<h3>Внос обвързвания</h3>
	 	<p>Малка, но важна особеност за <em>import</em> изявленията е, че те създават обвързвания на променливи, функции и класове, а не просто референции към тях. Това означава, че въпреки, че не можем да променяме импортирани идентификатори, те все още могат да променят себе си. Например, да предположим, че имаме този модул:</p>
	 			<pre class="highlight">
<span class="code">export</span> var name = "Nicholas";
<span class="code">export function</span> setName(newName) {
    name = newName;
}
	 			</pre>
	 	<p>Когато импортираме <em>name</em> и <em>setName()</em>, можем да видим, че <em>setName()</em> е в състояние да промени стойността на <em>name</em>:</p>
	 			<pre class="highlight">
<span class="code">import</span> { name, setName } from "example";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // error
	 			</pre>
	 	<p>Извикването на <em>setName("Greg")</em> се връща в модула, от който <em>setName()</em> се изнася и изпълнява и настройва <em>name</em> на "Greg". Имайте в предвид, че тази промяна се отразява автоматично върху вноса на <em>name</em> обвързването. Това е защото <em>name</em> е локално име на изнасяния <em>name</em> идентификатор, така че не са едно и също нещо.</p>
	 	</div>
	 	<h3>Износ и внос по подразбиране</h3>
	 	<p>Модул синтаксиса е наистина оптимизиран за износ и внос на стойности по подразбиране от модули. Стойността по подразбиране за един модул е променлива, функция или клас, които са посочени с ключовата дума <em>default</em>. Например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export default function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
}
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Този модул изнася функция по подразбиране. Ключовата дума <em>default</em> показва, че това е износ по подразбиране и функцията не изисква име, защото самия модул представлява функцията.</p>
	 	<p>Можем също да зададем идентификатор, като износ по подразбиране, като използваме синтаксиса за преименуване, като</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// еквивалентно на предишния пример</em></span>
<span class="code">function</span> sum(num1, num2) {
    <span class="code">return</span> num1 + num2;
}

<span class="code">export</span> { sum as <span class="code">default</span> };
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p><em>as default</em> уточнява, че <em>sum</em> трябва да бъде износа по подразбиране на модула. Този синтаксис е еквивалентен  на предишния пример.</p>
	 	<dl>
	 		<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Можем да имаме само един износ по подразбиране на модул. Използването на множество модули с ключовата дума <em>default</em> е синтактична грешка.</strong></dd>
	 	</dl>
	 	<p>Можем да импортираме стойност по подразбиране от модул използвайки следния синтаксис:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// внос по подразбиране</em></span>
<span class="code">import</span> sum from "example";

console.log(sum(1, 2));     // 3
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Това <em>import</em> изявление внася по подразбиране от модул "example". Обърнете внимание, че няма използване на фигурни скоби в този случай, както е при не по подразбиране износ. Локалното име <em>sum</em> се използва за представяне на функцията, като износ на модула. Този синтаксис е най-чист, като се очаква да бъде доминираща форма на внос от интернет, който позволява да използваме вече съществуващ обект, например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> $ from "jquery";	
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Модули, които изнасят едновременно по подразбиране и не по подразбиране, можем да ги импортираме с една декларация:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export let</span> color = "red";

<span class="code">export default function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
}
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Можем да импортираме <em>color</em> и функцията по подразбиране, използвайки следното:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> sum, { color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Запетаята разделя локалното име по подразбиране от не по подразбиране (което е заобиколено от фигурни скоби).</p>
	 	<p>Както експортиране по подразбиране, така и импортиране по подразбиране може да бъде постигнато в помощта на синтаксиса за преименуване.</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// еквивалентно на предишния пример</em></span>
<span class="code">import</span> { <span class="code">default</span> as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>В този код износа по подразбиране (<em>default</em>) е преименуван на <em>sum</em> и допълнителния износ <em>color</em> също се внася. Този пример е еквивалентен на предишния</p>
	 	<h3>Re-exporting</h3>
	 	<p>Възможно е някой път да искате да реекспортирате нещо, което модула е внесъл. Можем да направим това с моделите, които вече разгледахме в тази глава, като например:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> { sum } from "example";
<span class="code">export</span> { sum }
	 				
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Има една декларация, с която може да се постигне същото:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export</span> { sum } from "example";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тази форма на <em>export</em> оглежда в указания модул за декларация на <em>sum</em> и след това я изнася. Разбира се можем да изберем различно име за изнасяне на едно и също нещо.</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">export</span> { sum as add } from "example";
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Тука, <em>sum</em> се внася от "example" и след това се изнася, като <em>add</em>.</p>
	 	<p>Ако искате да изнасяте всичко от друг модул, можем да използваме модела със звезда * :</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">export</span> * from "example";	 			
	 		</pre></dd>
	 	</dl>
	 	<p>Чрез изнасяне на всичко, ние включваме по подразбиране, както и всяко име за износ, което може да повлияе на това, което може да експортираме от нашия модул. Например, ако "example" има износ по подразбиране, ще бъде в състояние да определи нов износ по подразбиране, когато използва този синтаксис.</p>
	 	<h3>Внос без обвързване</h3>
	 	<p>Някои модули не могат да изнасят нищо и вместо това, правят само модификации на обектите в глобалния обхват. Въпреки, че най-високото ниво променливи, функции и класове вътре в модула, не попадат автоматично е глобалния обхват, това не означава, че модулите не могат да получат достъп до глобалния обхват. Общите дефеници на вградени обекти, като <em>Array</em> и <em>Object</em> са достъпни във вътрешността на един модул и промени в тези обекти ще бъдат отразени в други модули.</p>
	 	<p>Да предположим, че искаме да добавим метод за всички масиви, наречени <em>pushAll()</em>, можем да дефинираме модул, като този:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="comment"><em>// код на модул без износ и внос</em></span>
<span class="code">Array</span>.prototype.pushAll = <span class="code">function</span>(items) {

    <span class="comment"><em>// елементите тябва да бъдат масив</em></span>
    <span class="code">if</span> (!<span class="code">Array</span>.isArray(items)) {
        <span class="code">throw new</span> TypeError("Argument must be an array.");
    }

    <span class="comment"><em> // използване на вграден push() и оператор spread</em></span>
    <span class="code">return this</span>.push(...items);
};
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>Това е валиден модул, въпреки, че няма износ и внос. Този код може да се използва, както от модул, така и от скрипт. Тъй като не изнася нищо, можем да използваме опростен внос за изпълнение на кода в модул, без импортни обвързвания:</p>
	 	<dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">import</span> "example";

<span class="code">let</span> colors = ["red", "green", "blue"];
<span class="code">let</span> items = [];

items.pushAll(colors);
	 			</pre>
	 		</dd>
	 	</dl>
	 	<p>В този пример, модула се внася и се изпълнява, така <em>pushAll()</em> е добавен към прототипа на масив. Това означава, че <em>pushAll()</em> е вече на разположение за използване от всички масиви във вътрешността на този модул.</p>
	 	<dl>
	 		<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Внос без обвързвания е най-вероятно да бъде използван за създаване на <em>polyfills</em> и <em>shims</em>.</strong></dd>
	 	</dl>
	 </article>
	 <footer>
	 	<h3>Обобщение</h3>
	 	<p>ECMAScript 6 добавя модули към езика, като начин за опаковане и капсулиране на функционалност. Модулите се държат различно от скриптовете, тъй като не променят глобалния обхват с техните променливи от най-високо ниво, функции, класове и <em>this</em> е <em>undefined</em>. С цел да се работи по различен начин от скриптове, модулите трябва да бъдат заредени с помощта на друг режим.</p>
	 	<p>Модула трябва да изнася всяка функционалност, която искате да се направи достъпна за потребителите на модула. Променливи, функции и класове могат да бъдат изнасяни, като има и един по подразбиране износ, разрешен за модули. След износа, друг модул може да внесе всички или някои от изнесените имена. Тези имена действат, като определени от <em>let</em> и така функционират, като блок обвързвания, които не могат да бъдат пре-декларирани в същия модул.</p>
	 	<p>Модулите не са длъжни да изнасят нищо, ако то е за манипулиране на глобалния обхват. В този случай, е възможно да се внася такъв модул, без да се въвеждат обвързвания в обхвата на модула.</p>
	 </footer>
	 <nav>
  <a href="./12_proxies_and_reflection.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./appendix_A.html" title="next chapter">▶</a>
</nav>
</body>
</html>