<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Символи :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="./05_destructured.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./07_set_and_map.html" title="next chapter">▶</a>
</nav>
	 
	 <header id="header" class="">
	 	<h1><div class="head-num">Глава 6</div>Символи</h1>
	 	<p>Символите са нов примитивен тип въведен в ECMAScript 6, свързващ съществуващите примитивни типове: <em>strings, numbers, booleans, null</em> и <em>undefined</em>. В ECMAScript 6 символите поставят началото на начин за създаване на частни членове на обекти, характеристика, която  JavaScript програмистите отдавна очакваха. Всяко свойство с име <em>string</em> е лесен начин за достъп, независимо от неяснотата на името. Първоначално значението на "частните имена" имаше за цел да създаде <em>non-string</em> свойство на имената. Но по този начин нормалните техники за откриване на тези частни имена нямаше да работят.</p>
	 	<p>Предложението за частни имена в крайна сметка се превърна в  ECMAScript 6 символи. Макар подробностите по изпълнението да остават същите (<em>non-string</em> стойности за свойство на имената), целта за неприкосновенност намаля. Вместо това, свойствата на символите се категоризират по отделно, без да са <em>non-enumerable</em> по подразбиране, но все още лесно откриваеми.</p>
	 	
	 </header><!-- /header -->
	 <article>
	 	<h3>Създаване на символи</h3>
	 	<p> Символите са уникални сред JavaScript примитивните типове, с това че не разполагат с литерална форма (<em>true</em> за булев тип или 42 за числа). Можем да създадем символ с помощта на глобалната <em>Symbol</em> функция, както в този пример:</p> 
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">var</span> firstName = Symbol();
<span class="code">var</span> person = {};

person[firstName] = "Nicholas";
console.log(person[firstName]);     // "Nicholas"
	 		</pre></dd>
	 	</dl>
	 	<p>В този пример символа <em>firstName</em> е създаден и се използва за присвояване от новото свойство <em>person</em>. Този символ трябва да се използва всеки път, когато искате да получите достъп до същото свойство. Това е добра идея да назовем променливата на символа подходящо, така че лесно да разберем какво представлява символа.</p>
	 	<dl>
	 		<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Тъй като символите са примитивни стойности, извикването на <em>new Symbol()</em> хвърля грешка. Възможно е да се създаде инстанция на <em>Symbol</em> чрез <em>new Object(yourSymbol)</em>, но не е ясно, кога това би било полезно.</strong></dd>
	 	</dl>
	 	<p>Функцията <em>Symbol</em> приема незадължителен аргумент с описанието на символа. Самото описание не може да се използва за достъп до свойството, но се използва с цел на отстраняване на грешки. Например:</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">var</span> firstName = Symbol("first name");
<span class="code">var</span> person = {};

person[firstName] = "Nicholas";

console.log("first name" in person);    // false
console.log(person[firstName]);         // "Nicholas"
console.log(firstName);                 // "Symbol(first name)"
	 		</pre></dd>
	 	</dl>
	 	<p>Описанието на символа се съхранява във вътрешно свойство, наречено [[Description]]. Това свойство се чете, когато метода <em>toString()</em> за символи се извика пряко или косвено (както в този пример). Няма друг възможен начин за достъп до [[Description]] директно с код. За това е препоръчително винаги да се предостави описание за четене на символа, така грешките се отстраняват по лесно.</p>
	 	<div class="aside">
	 	<h3>Идентифициране на символи</h3>
	 	<p>Тъй като, символите са примитивни стойности, можем да използваме оператора <em>typeof</em> за да определи дали дадена променлива съдържа символ. ECMAScript 6 разширява <em>typeof</em> да връща "symbol", когато се използва за символ. Например:</p>
	 	<pre class="highlight">
<span class="code">var</span> symbol = Symbol("test symbol");
console.log(<span class="code">typeof</span> symbol);    // "symbol"
	 		</pre>
	 	<p>Докато има и други косвени начини за определяне дали дадена променлива е символ, <em>typeof</em> е най-точен и предпочитан начин за това.</p>
	 	</div>
	 	<h3>Използване на символи</h3>
	 	<p>Можем да използваме символи навсякъде, където трябва да изчисляваме име на свойство. Вече сме виждали използването на скоби нотацията в тази глава, но можем да използваме символите за  изчисляване на имената на свойствата за обектите, както с <em>Object.defineProperty()</em> така и с <em>Object.defineProperties()</em>, като това:</p>
	 	<dl>
	 		<dd><pre class="highlight">
<span class="code">var</span>  firstName = Symbol("first name");
<span class="comment">// използва изчисляване на свойство за обект литерал </span>
<span class="code">var</span>  person = {
    [firstName]: "Nicholas"
};

<span class="comment">// прави свойството само за четене</span>
<span class="code">Object</span> .defineProperty(person, firstName, { writable: <span class="code">false</span>  });

<span class="code">var</span>  lastName = Symbol("last name");

<span class="code">Object</span> .defineProperties(person, {
    [lastName]: {
        value: "Zakas",
        writable: <span class="code">false</span> 
    }
});

console.log(person[firstName]);     // "Nicholas"
console.log(person[lastName]);      // "Zakas"
	 		</pre></dd>
	 	</dl>
	    <p>Този пример използва изчисляване на свойство за обект литерал, за създаване на <em>firstName</em> символ свойство. Свойството е създадено не номерирано, за разлика от изчислените свойства създадени с помощта на <em>nonsymbol</em> имена. Следващия ред, прави свойството само за четене. По-късно, свойството на символа само за четене <em>lastName</em> е създадено с помощта на <em>Object.defineProperties()</em>. Изчисляването на свойство за обект литерал се използва отново, само че този път е част от втория аргумент на <em>Object.defineProperties()</em>.</p>
	    <p>Докато символите могат да бъдат използвани на всяко място, където е позволено изчисляване на имена за свойства, трябва да има система за споделяне на тези символи за да ги използваме ефективно.</p>
	    <h3>Споделяне на символи</h3>
	    <p>Може да откриете, че искате различни части от вашия код да използват едни и същи символи. Да предположим, че имате два различни типа обекти във вашето приложение, които трябва да използват същото свойство на символ за предоставяне на уникален идентификатор. Следенето на символи във файлове или големи база код данни, може да бъде трудно и податливо на грешки. Ето защо  ECMAScript 6 осигурява глобален регистър на символи, до който може да получите достъп по всяко време.</p>
	    <p>Когато искате да създадете символ, който да бъде споделен, трябва да използвате <em>Symbol.for()</em> вместо <em>Symbol()</em>. Метода <em>Symbol.for()</em> приема един единствен параметър, който идентифицира <em>string</em> за символа, който искате да създадете (тази стойност се използва, като описание). Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">var</span> object = {};

object[uid] = "12345";

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"
	    	</pre></dd>
	    </dl>
	    <p>Метода <em>Symbol.for()</em> първо търси в глобален регистър за символи, за да види дали символ с ключ "uid" съществува. Ако е така, след това се връща на вече съществуващия символ. Ако няма съществуващ такъв символ, тогава създава нов символ и го регистрира в глобалния регистър за символи, използвайки указания ключ. След това новия символ се връща. Това означава, че следващите извиквания на <em>Symbol.for()</em> ще използват един и същи ключ за връщане на същия символ:</p>
	    <dl>
	    	<dd>
	    		<pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">var</span> object = {
    [uid]: "12345"
};

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"

<span class="code">var</span> uid2 = Symbol.<span class="code">for</span>("uid");

console.log(uid === uid2);      // true
console.log(object[uid2]);      // "12345"
console.log(uid2);              // "Symbol(uid)"
	    		</pre>
	    	</dd>
	    </dl>
	    <p>В този пример, <em>uid</em> и <em>uid2</em> съдържат един и същи символ, така че могат да се използват, като взаимозаменяеми. Първото извикване на <em>Symbol.for()</em> създава символ, а второто извлича символа от регистъра за глобални символи.</p>
	    <p>Друг уникален аспект на споделените символи е, че можем да извлечем ключа, свързан със символа в регистъра за глобални символи с помощта на <em>Symbol.keyFor()</em>, например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid");
console.log(Symbol.keyFor(uid));    // "uid"

<span class="code">var</span> uid2 = Symbol.<span class="code">for</span>("uid");
console.log(Symbol.keyFor(uid2));   // "uid"

<span class="code">var</span> uid3 = Symbol("uid");
console.log(Symbol.keyFor(uid3));   // undefined
	    	</pre></dd>
	    </dl>
	    <p>Забележете, че и двете <em>uid</em> и <em>uid2</em> връщат ключ "uid". Символа <em>uid3</em> не съществува в регистъра за глобални символи, така че няма ключ свързан с него и <em>Symbol.keyFor()</em> връща <em>undefined</em>.</p>
	    <dl>
	    	<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Регистърът за глобални символи е споделена среда, точно както глобалния обхват. Така че, не могат да се правят предположения, какво присъства или не в тази среда. Вие трябва да използвате пространството на имена за ключове на символи, за да се намали вероятноста от съвпадения при използване на компонентите от трета страна. Например, jQuery да има префикс за всички ключове "jquery.", като "jquery.element".</strong></dd>
	    </dl>
	    <h3>Символ коригиране на типа</h3>
	    <p>Коригирането на типа е значителна част от JavaScript и има много гъвкаво отношение към способноста на езика да коригира един тип данни в друг. Символите, обаче не са толкова гъвкави, когато става въпрос за коригиране, защото не съществува логическа еквивалентност на символ в другите типове. По-конкретно, символите не могат да бъдат коригирани в <em>strings</em> или <em>numbers</em>, така че не могат случайно да се използват, като свойства, които в противен случай се очакват да се държат, като символи.</p>
	    <p>Примерите в тази глава използват <em>console.log()</em> за да покажат на изхода, че символа работи, защото <em>console.log()</em> извиква <em>String()</em> върху своите аргументи. Можете да използвате <em>String()</em> директно за да получите същия резултат. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid"),
    desc = <span class="code">String</span>(uid);

console.log(desc);              // "Symbol(uid)"
	    	</pre></dd>
	    </dl>
	    <p>Функцията <em>String()</em> извиква <em>uid.toString()</em> и връща описанието на символ <em>string</em>. Ако се опитаме да свържем директно символа със <em>string</em>, ще бъде хвърлена грешка:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid"),
    desc = uid + "";            // error!
	    	</pre></dd>
	    </dl>
	    <p>Конкатенацията на <em>uid</em> с празен <em>string</em> изисква, първо <em>uid</em> да се коригира в <em>string</em>. Грешка се хвърля, когато е открито коригиране, предотвратявайки използването му по този начин.</p>
	    <p>По същия начин не може да се коригира символ в номер. Всички математически оператори предизвикват грешка, когато се прилагат за символ. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid"),
    sum = uid / 1;            // error!
	    	</pre></dd>
	    </dl>
	    <p>Този пример се опитва да раздели символ с 1, което води до грешка. Грешка се хвърля независимо от използвания математически оператор (логическите оператори не хвърлят грешка, защото всички символи се считат за еквивалент на <em>true</em>, точно както всяка друга не празна стойност в JavaScript).</p>
	    
	    <h3>Извличане на символи от обект</h3>
	    <p>Може би сте запознати със <em>Object.keys()</em> и <em>Object.getOwnPropertyNames()</em> за извличане на имената на свойства в даден обект, с първия за връщане на всички номерирани имена на свойства и втория за връщане на всички свойства независимо от номерирането. Нито един от тези методи, не връща свойства на символ, за да запази тяхната ECMAScript 5 функционалност. Вместо тях е добавен метода  <em>Object.getOwnPropertySymbols()</em>, който позволява извличане на свойства на символи от даден обект.</p>
	    <p>Върнатата стойност от <em>Object.getOwnPropertySymbols()</em> е масив от символи със собствените им свойства, например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">var</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">var</span> object = {
    [uid]: "12345"
};

<span class="code">var</span> symbols = Object.getOwnPropertySymbols(object);

console.log(symbols.length);        // 1
console.log(symbols[0]);            // "Symbol(uid)"
console.log(object[symbols[0]]);    // "12345"
	    	</pre></dd>
	    </dl>
	    <p>В този код, <em>object</em> има едно единствено свойство символ <em>uid</em>. Масивът върнат от <em>Object.getOwnPropertySymbols()</em> е масив съдържащ само този символ.</p>
	    <p>Всички обекти започват с нулеви символни свойства, обектите могат да наследяват символни качества от своите прототипи. ECMAScript 6 предварително настройва няколко такива свойства.</p>
	    <h3>Излагане на вътрешни операции с Well-Known символи</h3>
	    <p>Централна тема и за двете ECMAScript 5 и ECMAScript 6 е да изложи и определи някои "магически" части на JavaScript - частите, които не могат да бъдат пример за подражание от програмист. ECMAScript 6 следва тази традиция чрез излагане на повече от преди, на вътрешната логика на езика. Това се постига главно чрез използване на прототипа на символни свойства, които определят основното поведение на някои обекти.</p>
	    <p>ECMAScript 6 включва предварително зададени символи, наречени <em>well-known</em> (добре познати) символи, които показват общо поведение в JavaScript и които преди това са били считани само за вътрешни операции. Всеки <em>well-known</em> символ е представен от свойство на <em>Symbol</em> обекта, например като <em>Symbol.create</em></p>
	    <p><em>Well-known</em> символи са:</p>
	    <dl>
	    	<dd><ul>
	    		<li><strong>Symbol.hasInstance</strong> - метод използван от <em>instanceof</em> да определи наследството на даден обект.</li>
	    		<li><strong>Symbol.isConcatSpreadable</strong> - булева стойност, показваща дали употребата на <em>Array.prototype.concat()</em> ще изглади елементите на колекцията.</li>
	    		<li><strong>Symbol.iterator</strong> - метод, който връща iterator (обяснен в <a href="08_iterators_and_generators.html">Глава 8</a> - Iterators и Generators).</li>
	    		<li><strong>Symbol.match</strong> - метод използван от <em>String.prototype.match()</em> за сравняване на <em>strings</em>.</li>
	    		<li><strong>Symbol.replace</strong> - метод използван от <em>String.prototype.replace()</em> за заместване на <em>substrings</em>.</li>
	    		<li><strong>Symbol.search </strong> - метод използван от <em>String.prototype.search()</em> за намиране на <em>substrings</em>.</li>
	    		<li><strong>Symbol.species </strong> - конструктор от който са направени извлечените обекти (обяснен в <a href="09_classes.html">Глава 9</a> - Класове).</li>
	    		<li><strong>Symbol.split </strong> - метод използван от <em>String.prototype.split()</em> за разделяне на <em>strings</em>.</li>
	    		<li><strong>Symbol.toPrimitive </strong> - метод който връща представянето на примитивни стойности в обекта.</li>
	    		<li><strong>Symbol.toStringTag</strong> - <em>string</em> използван от <em>Object.prototype.toString()</em> за създаване на описание на обект.</li>
	    		<li><strong>Symbol.unscopables</strong> - обект, чиито свойства са имената на свойствата на обекта, които не трябва да бъдат включени в <em>with</em> изявлентие.</li>
	    	</ul></dd>
	    </dl>
	    <p>Някои от най-известните символи са обсъдени  по-долу , а други са разгледани в книгата, за да ги държи в правилния контекст.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Заменящия метод дефиниран с <em>well-known</em> символ, променя обикновен обект в екзотичен обект, защото това променя някои вътрешни поведения по подразбиране.</strong></dd>
	    </dl><br>
	    <h3>Symbol.hasInstance</h3>
	    <p><em>Symbol.hasInstance</em> е свойство на функциите, които определят дали даден обект е или не е инстанция на тази функция. Символът е представен в код от <em>Symbol.hasInstance</em> и свойството символ е дефинирано от <em>Function.prototype</em>, така че всички функции наследяват поведение по подразбиране за <em>instanceof</em>. Самото свойство се определя, като <em>nonwritable</em> и <em>nonconfigurable</em> , като <em>nonenumerable</em> гарантира, че не се презаписва по погрешка. Метода <em>Symbol.hasInstance</em> приема един аргумент за стойност на проверка и връща <em>true</em> ако стойността е инстанция на функцията.</p>
	    <p>За да разберем, как  <em>Symbol.hasInstancee</em> работи, нека да разгледаме следния код:</p>
	    <dl>
	    	<dd><pre class="highlight">
obj <span class="code">instanceof Array</span>;
	    	</pre></dd>
	    </dl>
	    <p>Този код е еквивалентен на:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">Array</span>[Symbol.hasInstance](obj);
	    	</pre></dd>
	    </dl>
	    <p>По същество, ECMAScript 6 предефинира <em>instanceof</em> оператора, като кратък запис на синтаксиса за извикване на този метод. И сега имаме участващ извикан метод, всъщност можем да променим начина на работа на <em>instanceof</em>.</p>
	    <p>Да предположим, че искаме да дефинираме функция, която претендира, че няма обект, като инстанция. Можем да го направим <em>hardcoding</em> връщайки от <em>Symbol.hasInstance false</em>, като:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">function</span> MyObject() {
    // ...
}

<span class="code">Object</span>.defineProperty(MyObject, Symbol.hasInstance, {
    value: <span class="code">function</span>(v) {
        <span class="code">return false</span>;
    }
});

<span class="code">var</span> obj = <span class="code">new</span> MyObject();

console.log(obj <span class="code">instanceof</span> MyObject);       // false
	    	</pre></dd>
	    </dl>
	    <p>Този пример използва <em>Object.defineProperty()</em>, за да презапише метода  <em>Symbol.hasInstance</em> с новата функция. (Трябва да използвате <em>Object.defineProperty()</em> за презаписване на <em>nonwritable</em> свойство.) Функцията винаги ще връща <em>false</em>, въпреки, че <em>obj</em> всъщност е инстанция на <em>MyObject</em>, защото оператора <em>instanceof</em> връща <em>false</em>.</p>
	    <p>Разбира се, може също да инспектира стойността и да реши дали стойността трябва да се разглежда, като нейна инстанция въз основа на всяко произволно състояние. Например, може би числа със стойност между 1 и 100, трябва да се считат за инстанция на специален вид номер:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">function</span> SpecialNumber() {
    // ...
}

<span class="code">Object</span>.defineProperty(SpecialNumber, Symbol.hasInstance, {
    value: <span class="code">function</span>(v) {
        <span class="code">return</span> (v <span class="code">instanceof Number</span>) && (v >= 1 && v <= 100);
    }
});

<span class="code">var</span> two = <span class="code">new Number</span>(2),
    zero = <span class="code">new Number</span>(0);

console.log(two <span class="code">instanceof</span> SpecialNumber);    // true
console.log(zero <span class="code">instanceof</span> SpecialNumber);   // false
	    	</pre></dd>
	    </dl>
	    <p>Този код дефинира <em>Symbol.hasInstance</em> метод и връща <em>true</em> ако стойността е инстанция на <em>Number</em> и също има стойност между 1 и  100.  Имайте в предвид, че левият операнд на <em>instanceof</em> трябва да бъде обект, за да задейства извикването към <em>Symbol.hasInstance</em>, докато <em>nonobjects</em> причинява <em>instanceof</em> просто да връща <em>false</em> през цялото време. Този код позволява на <em>SpecialNumber</em> да претендира, че <em>two</em> е инстанция на число въпреки, че няма пряка връзка между тях.</p>
	    <dl>
	    	<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Можете също така да замените по подразбиране <em>Symbol.hasInstance</em> на всички вградени функции, като <em>Date</em> и <em>Error</em>. Това не се препоръчва, тъй като ефектите върху вашия код може да бъдат неочаквани и объркващи. Добра идея е, да заменяте <em>Symbol.hasInstance</em> на вашите собствени функции само когато е необходимо.</strong></dd>
	    </dl>
	    <h3>Symbol.isConcatSpreadable</h3>
	    <p>JavaScript масивите имат <em>concat()</em> метод, който има за цел да залепи два масива заедно, например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ]);

console.log(colors2.length);    // 4
console.log(colors2);        // ["red","green","blue","black"]
	    	</pre></dd>
	    </dl>
	    <p>Този код конкатенира нов масив от края на <em>colors1</em> и създава <em>colors2</em>, в единичен масив с всички елементи от двата масива. Обаче, <em>concat()</em> може да приема <em>nonarray</em> аргументи и в този случай тези аргументи просто се добавят към края на масива. Например:</p>
	    <dl>
	    	<dd><pre class="highlight-overflow">
<span class="code">let</span> colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ], "brown");

console.log(colors2.length);    // 5
console.log(colors2);           // ["red","green","blue","black","brown"]
	    	</pre></dd>
	    </dl>
	    <p>Тука, допълнителния аргумент "brown" се подава на <em>concat()</em> и  се превръща в петия елемент на <em>colors2</em>. Защо масив от аргументи се третира по различен начин от <em>string</em> аргументи? Спецификацията казва, че масивите автоматично се разделят на техните отделни елементи, а всички други типове не. Преди ECMAScript 6, нямаше начин да се коригира това поведение.</p>
	    <p>Свойството <em>Symbol.isConcatSpreadable</em> е булева стойност, показваща дали даден обект има <em>lenght</em> свойство и цифрови ключове и дали тези номерирани стойности на свойства трябва да бъдат добавяни поотделно към резултата с <em>concat()</em>. Символът е представен в кода от <em>Symbol.isConcatSpreadable</em>, но за разлика от други <em>well-known</em> символи, това символ свойство не се подава на всички стандартни обекти по подразбиране. Вместо това, то е достъпно, като начин да се увеличи работата на <em>concat()</em> върху някои типове обекти, ефективно, като поведение на късо съединение по подразбиране. Това означава, че можем да определим, кой тип да се държи, като масиви в <em>concat()</em>, също като:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> collection = {
    0: "Hello",
    1: "world",
    length: 2,
    [Symbol.isConcatSpreadable]: true
};

<span class="code">let</span> messages = [ "Hi" ].concat(collection);

console.log(messages.length);    // 3
console.log(messages);           // ["hi","Hello","world"]
	    	</pre></dd>
	    </dl>
	    <p>Обекта <em>collection</em> в този пример, е настроен да изглежда, като масив: тoй има <em>length</em> свойство и два цифрови ключа. Свойството <em>Symbol.isConcatSpreadable</em> е определено на <em>true</em> за да покаже, че стойностите на свойствата трябва  да се добавят, като отделни елементи на масив. Когато <em>collection</em> се подаде на <em>concat()</em>, резултата е масив, който има "Hello" и "world", като отделни позиции след "hi".</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Може също да настроите <em>Symbol.isConcatSpreadable</em> на <em>false</em> за масив от подкласове, за да се предотврати елементите да бъдат слепени посредством <em>concat()</em>. Под-класовете се обсъждат в <a href="09_classes.html">Глава 9</a>.</strong></dd>
	    </dl>
	    <h3>Symbol.match, Symbol.replace, Symbol.search  и Symbol.split </h3>
	    <p>Винаги е имало тясна връзка между <em>strings</em> и регулярни изрази в JavaScript. Типа <em>string</em> по специално, има няколко метода, които приемат регулярни изрази, като аргументи.</p>
	    <dl>
	    	<dd>
	    		<ul>
	    			<li><strong>match(regex)</strong> - определя дали даден <em>string</em> съвпада с регулярен израз.</li>
	    			<li><strong>replace(regex, replacement)</strong> - замества съвпадащия регулярен израз с подменящия</li>
	    			<li><strong>search(regex)</strong> - открива съвпадение на регулярния израз вътре в <em>string</em></li>
	    			<li><strong>split(regex)</strong> - разделя <em>string</em> в масив по съвпаденията на регулярния израз</li>
	    		</ul>
	    	</dd>
	    </dl>
	    <p>Преди ECMAScript 6, начина по който тези методи са взаимодействали с регулярния израз е бил скрит от програмистите. Това означава, че не е имало начин да се имитира това, което регулярния израз прави с помощта на определени от програмиста обекти. ECMAScript 6 дефинира четири символа, които отговарят на тези четири метода, ефективно отговарящи на поведението на вградения <em>RegExp</em> обект.</p>
	    <p>Символите <em>Symbol.match, Symbol.replace, Symbol.search</em>  и <em>Symbol.split</em>  представляват методи на аргумента на регулярния израз, който трябва да се извика, като първи аргумент на <em>string</em> методите <em>match(), replace(), search()</em> и <em>split()</em>, съответно. Четирите символни свойства са дефинирани в <em>RegExp.prototype</em> , като те трябва да се използват по подразбиране при изпълнение на методите на <em>string</em>. Знаейки това, можем да използваме методите на <em>string</em> по начин, който е подобен на регулярен израз. За да направите това, може да използвате следния символ в кода:</p>
	   <dl>
	   	<dd>
	   		<ul>
	   			<li><strong>Symbol.match</strong> - функция, която приема за аргумент <em>string</em> и връща масив от съвпадения или <em>null</em>, ако не е намерила съвпадение.</li>
	   			<li><strong>Symbol.replace</strong> - функция, която приема за аргумент <em>string</em> и <em>string</em> замяна и връща <em>string</em>.</li>
	   			<li><strong>Symbol.search</strong> - функция, която приема за аргумент <em>string</em> и връща номера с индекса на съвпадението или  -1, ако не е намерила съвпадение.</li>
	   			<li><strong>Symbol.split</strong>- функция, която приема за аргумент <em>string</em>и връща масив съдържащ парчета от <em>string</em>-а, разделени от съвпаденията</li>
	   		</ul>
	   	</dd>
	   </dl>
	   <p>Ето един пример:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="comment">// ефективно еквивалентно на /^.{10}$/</span>
<span class="code">let</span> hasLengthOf10 = {
    [Symbol.match]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? [value.substring(0, 10)] : <span class="code">null</span>;
    },
    [Symbol.replace]: <span class="code">function</span>(value, replacement) {
        <span class="code">return</span> value.length === 10 ? replacement + value.substring(10) : value;
    },
    [Symbol.search]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? 0 : -1;
    },
    [Symbol.split]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? ["", ""] : [value];
    }
};

<span class="code">let</span> message1 = "Hello world",   // 11 characters
    message2 = "Hello John";    // 10 characters


<span class="code">let</span> match1 = message1.match(hasLengthOf10),
    match2 = message2.match(hasLengthOf10);

console.log(match1);            // null
console.log(match2);            // ["Hello John"]

<span class="code">let</span> replace1 = message1.replace(hasLengthOf10),
    replace2 = message2.replace(hasLengthOf10);

console.log(replace1);          // "Hello world"
console.log(replace2);          // "Hello John"

<span class="code">let</span> search1 = message1.search(hasLengthOf10),
    search2 = message2.search(hasLengthOf10);

console.log(search1);           // -1
console.log(search2);           // 0

<span class="code">let</span> split1 = message1.split(hasLengthOf10),
    split2 = message2.split(hasLengthOf10);

console.log(split1);            // ["Hello world"]
console.log(split2);            // ["", ""]
	   	</pre></dd>
	   </dl>
	   <p>Тука, <em>hasLengthOf10</em> е обект, предназначен да работи, като регулярен израз, който съвпада, когато дължината (<em>length</em>) на <em>string</em> е точно 10. Всеки от четирите метода се осъществява чрез използване на съответните символи и след това се извикват съответните методи на двата <em>strings</em>. Първия  <em>string, message1</em>, има 11 знака и така няма да съвпадне; втория <em>string, message2</em>, има 10 знака и така ще съвпадне. Въпреки, че не е регулярен израз <em>hasLengthOf10</em> се подава на всеки <em>string</em> метод и се използва правилно поради допълнителните методи.</p>
	   <p>Въпреки, че това е един прост пример, възможността да се извършват по-сложни съвпадения, от колкото е възможно в момента с регулярни изрази отваря много възможности.</p>
	   <h3>Symbol.toPrimitive</h3>
	   <p>JavaScript често се опитва да превърне обекти в примитивни стойности по подразбиране, когато се прилагат някои операции. Например, когато се сравнява <em>string</em> с обект с помощта на двойното равно (==), обекта се превръща в примитивна стойност преди това сравняване. Точно каква стойност трябва да се използва е вътрешна операция, която ECMAScript 6 излага чрез метода <em>Symbol.toPrimitive</em>.</p>
	   <p>Метода <em>Symbol.toPrimitive</em>  се определя за прототип на всеки стандартен тип и предписва точното поведение. Когато е необходимо примитивно преобразуване, се извиква <em>Symbol.toPrimitive</em> с един аргумент, посочен като <em>hint</em> в спецификацията. Аргумента <em>hint</em> е една от следните <em>string</em> стойности:</p>
	   <dl>
	   	<dd>
	   		<ul>
	   			<li><strong>"number"</strong> - номер, който трябва да бъде върнат</li>
	   			<li><strong>"string" </strong> - <em>string</em>, който трябва да се върне</li>
	   			<li><strong>"default"</strong> - операцията няма предпочитания за вида</li>
	   		</ul>
	   	</dd>
	   </dl>
	   <p>За повечето стандартни обекти, поведението на <em>number</em> режим е:</p>
	   <dl>
	   	<dd>
	   		<ol>
	   			<li>Извиква <em>valueOf()</em>, и ако резултата е примитивна стойност я връща.</li>
	   			<li>В противен случай, извиква <em>toString()</em> и ако резултата е примитивна стойност я връща.</li>
	   			<li>В противен случай хвърля грешка.</li>
	   		</ol>
	   	</dd>
	   </dl>
	   <p>По същия начин, за повечето стандартни обекти поведението на  <em>string</em> режим е:</p>
	   <dl>
	   	<dd>
	   		<ol>
	   			<li>Извиква <em>toString()</em> и ако резултата е примитивна стойност я връща.</li>
	   			<li>В противен случай, извиква <em>valueOf()</em> и ако резултата е примитивна стойност я връща.</li>
	   			<li>В противен случай хвърля грешка.</li>
	   		</ol>
	   	</dd>
	   </dl>
	   <p>В много случаи стандартните обекти третират режима по подразбиране, като равностоен на <em>number</em> режима (с изключение на <em>Date</em>, която се отнася към режима по подразбиране, като равностоен на <em>string</em> режима). Чрез дефиниране на <em>Symbol.toPrimitive</em>, можем да коригираме това поведение по подразбиране.</p>
	   <dl>
	   	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Режим по подразбиране се използва само за  ==, + и при подаване на единичен аргумент към <em>Date</em> конструктора. Повечето операции използват <em>string</em> или <em>number</em> режим.</strong></dd>
	   </dl>
	   <p>За да замените поведението по подразбиране, използвайте <em>Symbol.toPrimitive</em> и задайте функция, като негова стойност, Например:</p>
	   <dl>
	   	<dd><pre class="highlight">
<span class="code">function</span> Temperature(degrees) {
    <span class="code">this</span>.degrees = degrees;
}

Temperature.prototype[Symbol.toPrimitive] = <span class="code">function</span>(hint) {

    <span class="code">switch</span> (hint) {
        <span class="code">case</span> "string":
            <span class="code">return this</span>.degrees + "\u00b0"; // degrees symbol

        <span class="code">case</span> "number":
            <span class="code">return this</span>.degrees;

        <span class="code">case</span> "default":
            <span class="code">return this</span>.degrees + " degrees";
    }
};

<span class="code">var</span> freezing = <span class="code">new</span> Temperature(32);

console.log(freezing + "!");            // "32 degrees!"
console.log(freezing / 2);              // 16
console.log(<span class="code">String</span>(freezing));          // "32째"
	   	</pre></dd>
	   </dl>
	   <p>Този пример дефинира <em>Temperature</em> конструктор и заменя метода по подразбиране на <em>Symbol.toPrimitive</em> прототипа. Различна стойност се връща в зависимост от <em>hint</em>, където <em>string</em> режима връща температура с Unicode символа за градус, <em>number</em> режима връща само цифрова стойност и режима по подразбиране и добавя думата “degrees” след цифрите. Всяко от изявленията в <em>swich</em> води до различен режим : оператора + задейства режим по подразбиране, оператора / задейства номер режим и <em>String()</em> функцията задейства <em>string</em> режим. Въпреки че е възможно да върне различни стойности за всичките три режима, много по-често използвано е да настроите режима на по подразбиране да е същия, като за <em>string</em> или номер режим.</p>
	   <h3>Symbol.toStringTag</h3>
	   <p>Един от най-интересните проблеми на JavaScript е наличието на множество глобални среди на изпълнение. Това се случва в уеб-браузъри, когато една страница включва вградена рамка на друга страница, като  всяка от тях има собствена среда на изпълнение. В повечето случаи това не е проблем, тъй като данните могат да се предават напред и назад между среди без да причиняват безпокойство. Проблемът възниква, когато се опитваме да се идентифицираме типа на обекта, с който имаме работа след като е бил прехвърлен между различните обекти.</p>
	   <p>В каноничен пример, това е подаване на масив от вградената рамка в съдържащата страница или обратно. В ECMAScript 6 терминологията <em>iframe</em> и съдържаща страница представляват различни области, като изпълнителна среда за JavaScript. Всяка област има свой собствен глобален обхват с негово собствено копие на глобални обекти. В зависимост от това в коя област се създава масива, се определя вида на масива. Когато това е в различна среда на изпълнение <em>instanceof Array</em> връща <em>false</em>, защото масива е създаден с конструктор от различни среди.</p>
	   <h3>Временно решение за идентифициране на проблема</h3>
	   <p>Сблъсквайки се с този проблем разработчиците много скоро намериха добър начин да се идентифицират масиви. Те открили, че когато се извика стандартния метод <em>toString()</em> върху обект, се връща винаги предвидим <em>string</em>. По този начин , много JavaScript библиотеки, започнаха да включват функция, която работи подобно на това:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">function</span> isArray(value) {
    <span class="code">return Object</span>.prototype.toString.call(value) === "[object Array]";
}

console.log(isArray([]));   // true
	   	</pre></dd>
	   </dl>
	   <p>Това може да изглежда малко, като кръгово движение, но в действителност е установено, че това работи добре във всички браузъри. Метода <em>toString()</em> за масиви не е много полезен за тази цел, тъй като връща <em>string</em> от елементите, които съдържа. Метода <em>toString()</em> на <em>Object.prototype</em>, обаче, има тази идея, където са включени няколко вътрешно дефинирани имена в резултата. Чрез използване на този метод на обект, можем да изтеглим това, което околната среда на JavaScript смята за тип на данните.</p>
	   <p>Програмистите бързо осъзнаха, че тъй като няма начин да променят това поведение, е възможно да използват същия подход, който да прави разлика между местни обекти и тeзи създадени от разработчиците. Най-важния от тях е ECMAScript 5 JSON обекта.</p>
	   <p>Преди ECMAScript 5, много употребяван е <em>Douglas Crockford’s json2.js</em>, който създава глобален JSON обект. Когато браузърите започнаха да прилагат глобалния JSON обект, се наложи да се каже дали глобалния JSON е предоставен от самата среда на JavaScript или чрез някоя друга библиотека. С помощта на същата техника са създадени много функции, като тази:</p>
	   <dl>
	   	<dd><pre class="highlight">
<span class="code">function</span> supportsNativeJSON() {
    <span class="code">return typeof</span> JSON !== "undefined" &&
      <span class="code">Object</span>.prototype.toString.call(JSON) === "[object JSON]";
}
	   	</pre></dd>
	   </dl>
	   <p>Тука, е същата характеристика, която позволява на програмистите да идентифицират масиви в границите на вградената рамка и също предоставя начин да се разбере дали JSON е местен или не. Не-местен JSON обект ще върне [object Object], докато местния обект ще върне [object JSON]. От този момент на татък този подход се превърна в стандарт за идентифициране на местни обекти.</p>
	   <h3>Отговора на ECMAScript 6</h3>
	   <p>ECMAScript 6 обяснява това поведение чрез <em>Symbol.toStringTag</em> символа. Този символ представлява свойство на всеки обект, което определя, каква стойност трябва да се произведе, когато <em>Object.prototype.toString.call()</em> се извика върху него. За масив, функцията връща стойност обяснена за съхранение на "Array" в <em>Symbol.toStringTag</em> свойството. По същия начин, можем да определим <em>Symbol.toStringTag</em> стойността на местните обекти.</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

<span class="code">var</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "[object Person]"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Person]"
	   	</pre></dd>
	   </dl>
	   <p>В този пример, свойството <em>Symbol.toStringTag</em> се дефинира в <em>Person.prototype</em> за да осигури поведението по подразбиране за създаване на <em>string</em> представяне. Тъй като, <em>Person.prototype</em> наследява <em>Object.prototype.toString()</em>, стойността върната от <em>Symbol.toStringTag</em> се използва също, като извикване на <em>me.toString()</em>. Обаче, все още не можем да определим свой <em>toString()</em> метод, който осигурява различно поведение, без да засяга използването на <em>Object.prototype.toString.call()</em> метода. Ето как може да изглежда това:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

Person.prototype.toString = <span class="code">function</span>() {
    <span class="code">return this</span>.name;
};

<span class="code">var</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Person]"
	   	</pre></dd>
	   </dl>
	   <p>Този контекст дефинира <em>Person.prototype.toString()</em> да връща стойността на <em>name</em> свойството. Тъй като <em>Person</em> инстанцията вече не се наследява от <em>Object.prototype.toString()</em>, извиквайки <em>me.toString()</em> проявява различно поведение.</p>
	   <dl>
	   	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Всички обекти наследяват <em>Symbol.toStringTag</em> от <em>Object.prototype</em>, освен ако не е посочено нещо друго. Стойността на свойството по подразбиране е "Object".</strong></dd>
	   </dl>
	   <p>Няма ограничения с кои стойности може да бъде използван <em>Symbol.toStringTag</em> от разработчика върху определени обекти. Например, нищо не пречи да използваме "Array", като стойност на <em>Symbol.toStringTag</em>, също като:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Array";

Person.prototype.toString = <span class="code">function</span>() {
    <span class="code">return this</span>.name;
};

<span class="code">var</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Array]"
	   	</pre></dd>
	   </dl>
	   <p>Тука, резултата от извикването на <em>Object.prototype.toString()</em> е "[object Array]", което е същото, като което ще получим от действителен масив. Това подчертава факта, че  <em>Object.prototype.toString()</em> вече не е напълно надежден начин за идентифициране на типа на даден обект.</p>
	   <p>Възможно е да се промени <em>string</em> маркера на местния обект, чрез присвояване на <em>Symbol.toStringTag</em> на техния прототип. Например:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">Array</span>.prototype[Symbol.toStringTag] = "Magic";

<span class="code">var</span> values = [];

console.log(<span class="code">Object</span>.prototype.toString.call(values));    // "[object Magic]"
	   	</pre></dd>
	   </dl>
	   <p>Въпреки, че <em>Symbol.toStringTag</em> се презаписва за масивa в този пример, извикването на <em>Object.prototype.toString()</em> води до "[object Magic]". Въпреки, че не се препоръчва да се променят вградени обекти по този начин, няма нищо в езика, което да го забранява.</p>
	   <h3>Symbol.unscopables</h3>
	   <p>The <em>with</em> изявлението е една от най-спорните части в JavaScript. Първоначално предназначено за избягване на повторно писане, <em>with</em> изявлението по-късно става открито критикувано за правенето на кода по-трудно разбираем и отрицателните последици при изпълнение. В резултат на това, <em>with</em> изявлението не е разширено в <em>strict mode</em> режим( което се отразява на класове и модули, които са под <em>strict mode</em> режим, без право на изключения).</p>
	   <p> Въпреки, че няма бъдеще за <em>with</em> изявлението, ECMAScript 6 все още го поддържа в <em>nonstrict mode</em> режим и като такова, трябва да намери начин да позволи на кода да продължи да работи правилно с използването на  <em>with</em>.</p>
	   <p>За да се разбере сложността на тази задача, да разгледаме следния код:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="code">var</span> values = [1, 2, 3],
    colors = ["red", "green", "blue"],
    color = "black";

<span class="code">with</span>(colors) {
    push(color);
    push(...values);
}

console.log(colors);    // ["red", "green", "blue", "black", 1, 2, 3]
	   	</pre></dd>
	   </dl>
	   <p>В този пример, двете извиквания на <em>push()</em> вътре в <em>with</em> изявлението, са еквивалентни на <em>colors.push()</em>, защото <em>with</em> изявлението добавя <em>puhs</em> в локалното обвързване. Препратката към <em>color</em> се отнася до променливата, създадена извън <em>whit</em>, което прави <em>values</em> референтна.</p>
	   <p>За ECMAScript 6, метода <em>values()</em> е добавен в масиви (обсъдено в <a href="08_iterators_and_generators.html">Глава 8</a> - <em>Iterators</em> и <em>Generators</em>). Това би означавало, че препратката към <em>values</em> в последния пример, сега трябва да се отнася не към локалните променливи стойности, а към стойностите на метода <em>values</em> на масива и ще прекъсне кода. Ето, защо символа <em>Symbol.unscopables</em> съществува.</p>
	   <p>Символа <em>Symbol.unscopables</em> се използва за <em>Array.prototype</em> за да посочи, кои свойства не трябва да създават обвързвания във вътрешността на <em>with</em> изявлението. Когато е налице, <em>Symbol.unscopables</em> е обект, чийто ключове са идентификатори за пропускане на <em>whit</em> обвързвания и чийто стойности са <em>true</em> за прилагане на блока. Тук е по подразбиране за масиви:</p>
	   <dl>
	   	<dd><pre class="highlight-overflow">
<span class="comment">// вградено в ECMAScript 6 по подразбиране</span>
<span class="code">Array</span>.prototype[Symbol.unscopables] = <span class="code">Object</span>.assign(<span class="code">Object</span>.create(<span class="code">null</span>), {
    copyWithin: <span class="code">true</span>,
    entries: <span class="code">true</span>,
    fill: <span class="code">true</span>,
    find, <span class="code">true</span>,
    findIndex: <span class="code">true</span>,
    keys: <span class="code">true</span>,
    values: <span class="code">true</span>
});
	   	</pre></dd>
	   </dl>
	   <p>Обекта <em>Symbol.unscopables</em> има <em>null</em> прототип (създаден от <em>Object.create(null)</em>) и съдържа всички нови методи за масиви в  ECMAScript 6 (тези методи са разгледани подробно в <a href="08_iterators_and_generators.html">Глава 8</a> - Iterators и Generators и в <a href="10_array.html">Глава 10</a> - Масиви). Обвързванията за тези методи не са създадени вътре в <em>with</em> изявлението, което позволява на стария код да продължи да работи без никакъв проблем.</p>
	   <p>По принцип, не трябва да се дефинира <em>Symbol.unscopables</em> за вашите обекти, освен ако не използвате <em>with</em> изявление или се правят промени в съществуващ обект във вашия база код.</p>
	 </article>
	 <footer>
	 	<h3>Обобщение</h3>
	 	<p>Символите са нов вид примитивни стойности в JavaScript и се използват за създаване на <em>nonenumerable</em> свойства, които изискват символа за достъп. Докато не са наистина частни, с тези свойства е трудно да се променя или заменя и следователно са подходящи за функционалност, която се нуждае от ниво на защита от страна на разработчиците.</p>
	 	<p>Може да предоставите описание за символи, което дава възможност за по-лесно идентифициране на символ стойности. Има глобален символ регистър, който позволява използването на споделени символи в различни части на кода с помощта на едно и също описание. По този начин един и същи символ може да се използва по същата причина на няколко места.</p>
	 	<p>Символите не се връщат в методи, както <em>Object.keys()</em> или <em>Object.getOwnPropertyNames()</em>, така че е добавен нов метод, <em>Object.getOwnPropertySymbols()</em>, който дава възможност за извличане на символни свойствата. Вие можете да направите промени в символ свойствата, чрез използване на <em>Object.defineProperty()</em> и <em>Object.defineProperties()</em>.</p>
	 	<p><em>Well-known</em> символите са дефинирани преди това, само за вътрешна функционалност за стандартни обекти и използват глобално достъпни символни константи, като <em>Symbol.hasInstance</em>. Тези символи използват префикс <em>Symbol</em> в спецификацията и позволяват на програмистите да модифицират поведението на стандартен обект по най-различни начини.</p>
	 </footer>
	 <nav>
	<a href="./05_destructured.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./07_set_and_map.html" title="next chapter">▶</a>
</nav>
</body>
</html>