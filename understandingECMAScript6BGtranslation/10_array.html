<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Масиви :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="09_classes.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="11_promises.html" title="next chapter">▶</a>
</nav>
	<header id="header" class="">
		<h1><div class="head-num">Глава 10</div>Масиви</h1>
		<p>Масивите са едни от най-фундаменталните JavaScript обекти, още от първите дни на езика. За съжаление масивите останаха непроменени през по-голямата част от съществуването си, докато  ECMAScript 5 не въвежда някои нови методи за масиви. ECMAScript 6 продължава тенденцията за актуализиране на масивите с по-голяма функционалност.</p>	
	</header><!-- /header -->
	<article>
		<h3>Създаване на масиви</h3>
		<p>Преди ECMAScript 6, двата основни начина за създаване на масиви са : <em>Array</em> конструктор и масив литерал синтаксис. И двата подхода изискват индивидуален списък с елементите на масива и иначе са доста ограничени. Ако сте имали масиво подобен обект (обект с цифрови индекси и <em>length</em> свойство) и искате да го конвертирате в реален масив, възможностите са доста ограничени и често изискват допълнителен код. Въпреки че, тези ограничения изглеждат малки, те се оказаха доста неприятни за големи приложения с JavaScript, които правят много манипулации с масиви. За да направи нещата по-лесни, ECMAScript 6 добавя два нови метода: <em>Array.of()</em> и <em>Array.from()</em>.</p>
		<h3>Array.of()</h3>
		<p>JavaScript отдавна имаше хрумване около създаването на масиви с <em>Array</em> конструктора. Поведението на <em>new Array()</em> се държи по различен начин въз основа на типа и броя аргументи подадени в него. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> items = <span class="code">new</span> Array(1, 2);        // length is 2
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = <span class="code">new Array</span>(2);
console.log(items.length);          // 2
console.log(items[0]);              // undefined
console.log(items[1]);              // undefined

items = <span class="code">new Array</span>(3, "2");
console.log(items.length);          // 2
console.log(items[0]);              // 3
console.log(items[1]);              // "2"

items = <span class="code">new Array</span>("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"
			</pre></dd>
		</dl>
		<p>Когато на <em>Array</em> конструктора е подадена една единствена цифрова стойност, тази стойност се очаква да бъде дължината на масива; ако се подаде една не-цифрова стойност, тогава тази стойност става един единствен елемент в масива; ако са подадени няколко стойности (цифрови или не), тогава тези стойности стават елементи на масива. Това поведение е едновременно объркващо и рисковано, тъй като не винаги можем да бъдем наясно с типа на данните, които се подават.</p>
		<p>ECMAScript 6 въвежда <em>Array.of()</em> за да реши този проблем. <em>Array.of()</em> работи по начин, подобен на <em>Array</em> конструктора. Единствената разлика е премахването на специалния случай по отношение на единичната цифрова стойност. Метода на <em>Array.of()</em> винаги създава масив, съдържащ неговите аргументи, независимо от броя или типа на аргументите. Ето няколко примера:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> items = <span class="code">Array</span>.of(1, 2);         // length is 2
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = <span class="code">Array</span>.of(2);
console.log(items.length);          // 1
console.log(items[0]);              // 2

items = <span class="code">Array</span>.of("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"
			</pre></dd>
		</dl>
		<p>Метода на <em>Array.of()</em> е подобен на използването на масив литерал, което означава, че можем да използваме масив литерал вместо <em>Array.of()</em> за локални масиви през по-голямата част от времето. Ако някога ви се наложи да подадете <em>Array</em> конструктор във функция, тогава може би е по-добре да подадете <em>Array.of()</em> за да се получи последователно поведение. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> createArray(arrayCreator, value) {
    <span class="code">return</span> arrayCreator(value);
}

<span class="code">let</span> items = createArray(<span class="code">Array</span>.of, value);
			</pre></dd>
		</dl>
		<p>В този код, функцията <em>createArray()</em> приема <em>arrayCreator</em> функиця и  стойност, за вмъкване в масива. След това можем да подадем <em>Array.of</em>, като първи аргумент на <em>createArray()</em> за създаване на нов масив. Би било опасно, директно подаване на <em>Array</em> ако не може да се гарантира, че подадената стойност няма да е номер.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Метода <em>Array.of()</em> не използва <em>Symbol.species</em> свойство (обсъдено в <a href="09_classes.html">Глава 9</a>) за да определи типа на върнатата стойност. Вместо това използва текущ конструктор (това е вътре в <em>of()</em>) за да определи правилния тип данни, които да върне.</strong></dd>
		</dl>
		<h3>Array.from()</h3>
		<p>Една от най-тромавите задачи в JavaScript е конвертиране на не-масиви обекти в реални масиви. Например, ако имате <em>arguments</em> обект (който е масиво-подобен) и искате да работите с него, като че ли е масив, тогава първо трябва да го конвертирате. В ECMAScript 5  ще напишете функция, като тази:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> makeArray(arrayLike) {
    <span class="code">var</span> result = [];

    <span class="code">for</span>(<span class="code">var</span> i = 0, len = arrayLike.length; i < len; i++) {
        result.push(arrayLike[i]);
    }

    <span class="code">return</span> result;
}

<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = makeArray(arguments);

    // use args
}
			</pre></dd>
		</dl>
		<p>Този подход ръчно създава масив и копира всеки елемент от <em>arguments</em> в този нов масив. Макар, че работи това е една прилична сума от код, за да се изпълни сравнително проста операция. Програмистите, скоро открили начин, с който да съкратят количеството код с помощта на метода за масиви <em>slice()</em>, използван върху масиво-подобни обекти:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> makeArray(arrayLike) {
    <span class="code">return Array</span>.prototype.slice.call(arrayLike);
}

<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = makeArray(arguments);

    // use args
}
			</pre></dd>
		</dl>
		<p>Въпреки, че това изисква по-малко писане, никак не е ясно, че <em>Array.prototype.slice.call()</em> означава “конвертиране в масив.” Това работи, защото сме определили <em>this</em> стойността за <em>slice()</em> към масиво- подобен обект. Тъй като, <em>slice()</em> се нуждае само от цифрови индекси и <em>length</em> свойство, за да работи правилно, всеки масиво-подобен обект ще работи.</p>
		<p>Метода <em>Array.from()</em> се добавя в ECMAScript 6, като по-разбираем начин за конвертиране на обекти в масиви. Можем да подадем <em>iterable</em> или масиво-подобен обект, като първи аргумент и <em>Array.from()</em> ще върне масив. Ето един прост пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = <span class="code">Array</span>.from(arguments);

    // use args
}
			</pre></dd>
		</dl>
		<p>Извикването на <em>Array.from()</em> в този пример, създава нов масив на базата на елементите в <em>arguments</em>. Така че, <em>args</em> е инстанция на <em>Array</em> който съдържа същите стойности в същите позиции, както <em>arguments</em>.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong><em>Array.from()</em> също използва <em>this</em> за да определи типа на масива, който трябва да върне.</strong></dd>
		</dl>
		<h3>Mapping Conversion</h3>
		<p>Ако искате да отидете една крачка напред, можете да предоставите втори аргумент на <em>Array.from()</em>, който е <em>mapping</em> функция, която се използва за конвертиране на всяка стойност в крайна форма. Например:</p>
		<dl>
		<dd><pre class="highlight">
<span class="code">function</span> translate() {
    <span class="code">return Array</span>.from(arguments, (value) => value + 1);
}

<span class="code">let</span> numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
			</pre></dd>
		</dl>
		<p>Тука, <em>Array.from()</em> се използва с <em>mapping</em> функция, която добавя едно за всеки елемент в масива. Ако <em>mapping</em> функцията е върху обект, можем по желание да подадем трети аргумент на <em>Array.from()</em> който представлява <em>this</em> стойността за <em>mapping</em> функцията, също като:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> helper = {
    diff: 1,

    add(value) {
        <span class="code">return</span> value + <span class="code">this</span>.diff;
    }
};

<span class="code">function</span> translate() {
    <span class="code">return Array</span>.from(arguments, helper.add, helper);
}

<span class="code">let</span> numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
			</pre></dd>
		</dl>
		<p>Този пример използва <em>helper.add()</em> метод, като <em>mapping</em> функция за конвертиране. Тъй като, <em>helper.add()</em> използва <em>this.diff</em>, трябва да се предостави трети аргумент за <em>Array.from()</em> за определяне на стойността на <em>this</em>. По този начин, <em>Array.from()</em> може лесно да се справя с конвертиране на данни без да е необходимо да се използва <em>bind()</em> или друг начин за определяне на <em>this</em> стойността.</p>
		<h3>Използване на Iterables</h3>
		<p>Метода <em>Array.from()</em> работи с масиво-подобни обекти и <em>iterables</em>. Това означава, че всеки обект с <em>Symbol.iterator</em> свойство може да се конветтира в масив, използвайки <em>Array.from()</em>. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = {
    *[Symbol.iterator]() {
        <span class="code">yield</span> 1;
        <span class="code">yield</span> 2;
        <span class="code">yield</span> 3;
    }
};

<span class="code">let</span> numbers2 = <span class="code">Array</span>.from(numbers, (value) => value + 1);

console.log(numbers2);              // 2,3,4
	    	</pre></dd>
	    </dl>
	    <p>В този код, <em>numbers</em> обекта е <em>iterable</em>, така че не може да се подаде директно към <em>Array.from()</em>, за конвертиране на неговите стойности в масив. <em>Mapping</em> функцията добавя едно към всеки брой, така полученият масив съдържа 2, 3 и 4, вместо 1, 2 и 3.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Ако един обект е едновременно масиво-подобен и <em>iterable, Array.from()</em> използва итератора за определяне на стойностите за конвертиране. </strong></dd>
	    </dl>
	    <h3>Нови методи</h3>
	    <p>Продължавайки тенденцията от ECMAScript 5, ECMAScript 6 добавя нови методи за масиви. Докато първите два метода, <em>find()</em> и <em>findIndex()</em> са предназначени за подпомагане на всички разработчици, другите <em>fill()</em> и <em>copyWithin()</em> са до голяма степен вдъхновени от използването за случаи с <em>typed arrays</em> (обсъдени по-късно в тази глава).</p>
	    <h3>Методите find() и findIndex()</h3>
	    <p>Преди ECMAScript 5, търсенето през масиви е било тромаво, защото не е имало вградени методи за това. ECMAScript 5 добавя <em>indexOf()</em> и <em>lastIndexOf()</em>, които най-накрая позволяват на разработчиците да търсят конкретни стойности вътре в масива. Като голямо подобрение, тези два метода са все още доста ограничени, защото само можем да търсим дадена стойност в даден момент (което означава, че ако искаме да намерим първото четно число в поредица от цифри, например, ще трябва да напишем наш собствен код за да го направим). ECMAScript 6 решава този проблем, чрез въвеждане на два нови метода: <em>find()</em> и <em>findIndex()</em>.</p>
	    <p>Методите <em>find()</em> и <em>findIndex()</em> работят по същия начин. И двата приемат два аргумента, функция за обратно извикване и не задължителна стойност за използване на <em>this</em> вътре във функцията. Функцията за обратно извикване се подава на елемент на масив, индекса на този елемент в масива и самия масив (същите аргументи, като за <em>map()</em> и <em>forEach()</em>) и трябва да върне <em>true</em>, ако дадената стойност отговаря на определени критерии. И двата, <em>find()</em> и <em>findIndex()</em> спират търсенето в масива при първото връщане на <em>true</em> от функцията за обратно извикване, единствената разлика е, че <em>find()</em> връща стойността, докато <em>findIndex()</em> връща индекса, на който е установена стойността. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = [25, 30, 35, 40, 45];

console.log(numbers.find(n => n > 33));         // 35
console.log(numbers.findIndex(n => n > 33));    // 2
	    	</pre></dd>
	    </dl>
	    <p>Този код използва, <em>find()</em> и <em>findIndex()</em> за намиране на първата стойност в <em>numbers</em> масива, която е по-голяма от 33. Извикването на <em>find()</em> връща 35, докато <em>findIndex()</em> връща 2, местоположението на 35 в <em>umbers</em> масива.</p>
	    <p>И двата, <em>find()</em> и <em>findIndex()</em> са полезни за намиране на елемент в масив, който съвпада с условието, а не със стойността. Ако искате само да намерите стойност, тогава <em>indexOf()</em> и <em>lastIndexOf()</em> са по-добър избор.</p>
	    <h3>Метода  fill()</h3>
	    <p>Метода <em>fill()</em> запълва един или повече елементи в масив с определена стойност. Когато се подаде стойност, <em>fill()</em> презаписва всички стойности в масива с тази стойност. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

numbers.fill(1);

console.log(numbers.toString());    // 1,1,1,1
	    	</pre></dd>
	    </dl>
	    <p>Тука, извикването на <em>numbers.fill(1)</em> променя всички стойности в <em>numbers</em> на 1. Ако искате да се променят само някои от елементите, а не всички от тях, може евентуално да включва начало и край индекси, като например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

numbers.fill(1, 2);

console.log(numbers.toString());    // 1,2,1,1

numbers.fill(0, 1, 3);

console.log(numbers.toString());    // 1,0,0,1
	    	</pre></dd>
	    </dl>
	    <p>В този пример, последните два елемента са запълнени с 1 от <em>numbers.fill(1, 2)</em>, като 2 показва индекса. от който да започне запълването на елементите. Индекса за край се счита за <em>numbers.length</em> защото не е посочен. Следващата операция, <em>numbers.fill(0, 1, 3)</em>, запълва масив с елементи на индекси 1 и 2 с 0. По този начин, сме в състояние да запълним няколко елемента наведнъж без да се презаписва целия масив.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Ако индексите за начало или край са отрицателни, тогава тези стойности се добавят към дължината на масива, за да се определи крайното местоположение. Например, старт местоположение на  -1 означава, че индекса ще бъде <em>array.length-1</em>, където array е масива върху, който <em>fill()</em> се извиква.</strong></dd>
	    </dl>
	    <h3>Метода copyWithin()</h3>
	    <p>Метода <em>copyWithin()</em> е подобен на <em>fill()</em>, в който се променят няколко елемента в масив едновременно. Обаче, вместо да посочва една стойност за присвояване от масив с елементи, <em>copyWithin()</em> позволява да копираме стойността на елемент в масив от самия масив. За да постигнем това, трябва да подадем два аргумента към <em>copyWithin()</em>, индекса, чиито стойности трябва да бъдат запълнени и началния индекс, чиито стойности трябва да бъдат копирани. Например, ако искате да копирате стойностите от първите два елемента в масива, върху последните два елемента в масива, може да го направите по следния начин:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

<span class="comment"><em>//поставяне на стойности в масив, започвайки от индекс 2</em></span>
<span class="comment"><em>//копиране на стойности в масив, започвайки от индекс 0</em></span>
numbers.copyWithin(2, 0);

console.log(numbers.toString());    // 1,2,1,2
	    	</pre></dd>
	    </dl>
	    <p>Този код копира стойности в <em>numbers</em> започвайки от индекс 2, така че двата индекса 2 и 3 ще бъдат презаписани. Вторият аргумент на <em>copyWithin()</em> е 0, което показва началото за копиране на стойности от индекс 0 и да продължи, докато няма повече елементи за копиране.</p>
	    <p>По подразбиране, <em>copyWithin()</em> винаги копира стойности до края на масива, но можете да предоставите трети не задължителен аргумент, за ограничаване на елементите, които трябва да бъдат презаписани. Този трети аргумент е без изключение на крайния индекс, в който копирането на стойности спира. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

<span class="comment"><em>//поставяне на стойности в масив, започвайки от индекс 2</em></span>
<span class="comment"><em>//копиране на стойности в масив, започвайки от индекс 0</em></span>
<span class="comment"><em>//спиране на копирането на стойности, в индекс 1</em></span>
numbers.copyWithin(2, 0, 1);

console.log(numbers.toString());    // 1,2,1,4
	    	</pre></dd>
	    </dl>
	    <p>В този, пример определения за краен индекс е настроен на 1 така, че само стойността на индекс 0 се копира. Последния елемент в масива остава не променен.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Както и при <em>fill()</em>, ако се подаде отрицателно число за всеки аргумент на <em>copyWithin()</em>, дължината на масива автоматично се добавя към тази стойност, за да се определи индекса за използване.</strong></dd>
	    </dl>
	    <p>Случаи на употреба за <em>fill()</em> и <em>copyWithin()</em> може да не са очевидни за вас в този момент. Това е така, защото тези методи са възникнали първоначлно за <em>typed arrays</em> и след това за съгласуваност са добавени за редовни масиви. Все пак, ако се окажете пред <em>typed arrays</em> за манипулиране с пробитово изместване на редицата, тези методи са много полезни.</p>
	    <h3>Typed Arrays</h3>
	    <p><em>Typed arrays</em> са специални масиви, предназначени за работа с цифрови типове (не всички видове, както може да изглежда от името). Произхода на <em>typed arrays</em> може да бъде проследен обратно до WebGL, пристанище на Open GL ES 2.0 предназначен за работа в уеб-страници с &ltcanvas&gt елемент. <em>Typed arrays</em> са създадени, като част от този порт, за осигуряване на бърза пробитова аритметика в JavaScript. Натуралните JavaScript номера са твърде бавни, което се дължи на складирането в 64-битов с плаваща запетая формат и за това се конвертират в 32-битови цели числа когато е необходимо, така че <em>typed arrays</em> са въведени за заобикаляне на това ограничение и осигуряване на по-добра производителност за тези операции. Концепцията е, че всеки номер може да бъде третиран, като масив от битове и по този начин може да се използват <em>typed</em> методи за разположение в JavaScript масивите.</p>
	    <p>ECMAScript 6 прие <em>typed arrays</em>, като официална част на езика, за да се гарантира по-добра съвместимост с цялата JavaScript машина и оперативна съвместимост с JavaScript масивите. Докато версията за <em>typed arrays</em> в ECMAScript 6 не е точно същата, както версията на WebGL, те са достатъчно сходни, за да направят с версията на ECMAScript 6 еволюция в WebGL, а не по-различен подход.</p>
	    <h3>Цифрови типове данни</h3>
	    <p>JavaScript номерата се съхраняват в IEEE 754 формат, използвайки 64 бита за съхранение с плаваща запетая за представяне на броя. Този формат представлява <em>integers</em> (цели) и <em>floats</em> (десетични) числа в JavaScript, с конвертиране между двата формата, което се случва често, когато номерата са се променили. Масивите позволяват съхранението и манипулирането на осем различни типове на номера:</p>
	    <dl>
	    	<dd>
	    		<ol>
	    			<li>Signed 8-bit integer (int8)</li>
	    			<li>Unsigned 8-bit integer (uint8)</li>
	    			<li>Signed 16-bit integer (int16)</li>
	    			<li>Unsigned 16-bit integer (uint16)</li>
	    			<li>Signed 32-bit integer (int32)</li>
	    			<li>Unsigned 32-bit integer (uint32)</li>
	    			<li>32-bit float (float32)</li>
	    			<li>64-bit float (float64)</li>
	    		</ol>
	    	</dd>
	    </dl>
	    <p>Ако искате да представите <em>int8</em> днес в JavaScript номер, вие ще загубите 56 бита. Тези битове може по-добре да се използват за съхранение на допълнителни <em>int8</em> (или друг номер, който изисква по-малко от 56 бита). Това е един от случаите на употреба на <em>typed arrays</em> адрес.</p>
	    <p>Всички операции и обекти свързани с <em>typed arrays</em> са центрирани около осемте типа данни. За да ги използвате, обаче, ще трябва да създадете <em>array buffer</em> (буфер масив) за съхранение на данни.</p>
	    <h3>Array buffer</h3>
	    <p>Фундамента в основата на всички <em>typed arrays</em> е <em>array buffer</em>. Един <em>array buffer</em> е място в паметта за всеки номер от байтове. Създаването на <em>array buffer</em> е равносилно на нещо, като <em>malloc()</em> извикване в C, за разпределяне на памет без да се уточнява, какво се съдържа в нея. Можем да създадем <em>array buffer</em> с помощта на <em>ArrayBuffer</em> конструктора и подаване на броя от байтове, които да съдържа:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes
	    		
	    	</pre></dd>
	    </dl>
	    <p>Веднъж създаден, можем да извлечем броя на байтовете в <em>array buffer</em> с помощта на <em>byteLength</em> свойството:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes
console.log(buffer.byteLength);     // 10
	    	</pre></dd>
	    </dl>
	    <p>Единственото друго нещо, което можем да направим е да създадем нов <em>array buffer</em>, който да съдържа част от съществуващия <em>array buffer</em> с помощта на <em>slice()</em> метод. Метода <em>slice()</em> работи по подобен начин, както метода за масиви <em>slice()</em>, в който се подава начален и краен индекс, като аргументи и след това връща нов <em>ArrayBuffer</em>, който е съставен от елементите на оригинала. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes


<span class="code">let</span> buffer2 = buffer.slice(4, 6);
console.log(buffer2.byteLength);    // 2	    		
	    	</pre></dd>
	    </dl>
	    <p>В този код, <em>buffer2</em> е създаден с екстракт от байтове с индекс 4 и 5 (включитело и втория аргумент за <em>slice()</em>, също като за масиви).</p>
	    <p>Разбира се, създаването на място за съхранение не е много полезно, без да може да се записват данни в това място. За да направим това, трябва да създадем <em>view</em>.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Имайте в предвид, че не може да променяте броя на байтовете, които <em>array buffer</em> представлява. Те винаги представляват точно определения брой. Можете да променяте данните съдържащи се в рамките на <em>array buffer</em>, но не и големината на самия <em>array buffer</em>.</strong></dd>
	    </dl>
	    <h3>Views</h3>
	    <p>Докато <em>array buffer</em> представлява място в паметта, <em>views</em> е интерфейс, чрез който се манипулира тази памет. <em>View</em> работи в <em>array buffer</em> или част от байтовете на <em>array buffer</em>, като чете и пише данни в определен формат. Типа <em>DataView</em> е общ <em>view</em>, който позволява да се работи с всички осем типа цифрови данни. За да направим това, първо трябва да създадем <em>ArrayBuffer</em> и след това да го използваме за да създадем <em>new DataView</em>. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view = <span class="code">new</span> DataView(buffer);	
	    	</pre></dd>
	    </dl>
	    <p>Обекта <em>view</em> в този пример, има достъп до целият 10 байтов <em>buffer</em>. Алтернативно можем да създадем <em>view</em> над само част от буфера, чрез осигуряване на байт за отместване и евентуално, броя на байтовете, които да се включат в това отместване (по подразбиране в края на буфера, когато няма представяне). Например</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view = <span class="code">new</span> DataView(buffer, 5, 2);      // cover bytes 5 and 6
	    	</pre></dd>
	    </dl>
	    <p>Тука, <em>view</em> действа само върху байтове с индекс 5 и 6. Този подход позволява създаване на няколко <em>views</em> над същия <em>array buffer</em>, което може да бъде полезно, ако искате да имате само част от място в паметта за цялото приложение, вместо динамично разпределяне на пространство, когато е необходимо.</p>
	    <h3>Извличане на View информация</h3>
	    <p>Можем да извлечем информация относно <em>view</em>, използвайки следните само за четене свойства.</p>
	    <dl>
	    	<dd>
	    		<ul>
	    			<li><strong><em>buffer</em></strong> - <em>array buffer</em>, с който <em>view</em> е свързан</li>
	    			<li><strong><em>byteOffset</em></strong> - втори аргумент към <em>DataView</em> конструкотра, ако е предвиден (0 по подразбиране)</li>
	    			<li><strong><em>byteLength</em></strong> - трети аргумент към <em>DataView</em> конструктора, ако е предвиден (буфера има <em>byteLength</em> по подразбиране)</li>
	    		</ul>
	    	</dd>
	    </dl>
	    <p>Използвайки тези свойства, можем да проверим, къде точно view работи, например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view1 = <span class="code">new</span> DataView(buffer),           // cover all bytes
    view2 = <span class="code">new</span> DataView(buffer, 5, 2);     // cover bytes 5 and 6

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
	    	</pre></dd>
	    </dl>
	    <p>Този код създава две <em>views, view1</em>, който действа върху целия буфер и <em>view2</em>, който действа върху малък участък от буфера на масива. Свойството <em>buffer</em> за всяко <em>view</em> е същото, защото и двете работят върху един и същи <em>array buffer</em>. The <em>byteOffset</em> и <em>byteLength</em> са различни за всяко <em>view</em>, отразявайки, къде точно в <em>array buffer</em> действа <em>view</em>.</p>
	    <p>Разбира се, четенето на информация за паметта не е много полезно, само по себе си. Трябва да запишем данни във и да четем тези данни от паметта, за да извлечем някаква полза.</p>
	    <h3>Четене и писане на данни</h3>
	    <p>Има два метода за всеки от осемте цифрови типове данни, един за писане на данни и един за четене на данни. Методите са с имена, започващи с “set” или “get”, последвани от съкращението на типа данни. Метода “set” приема три аргумента, за отместването на байта, в който се пише, стойността за записване и незадължителна булева стойност, показваща, че стойността трябва да се съхранява в малък-къс формат (с най-маловажния бит в байт 0, вместо в последния байт). Метода “get” приема два аргумента, за отместването на байта за четене и незадължителна булева стойност, показваща, стойността, която трябва да се чете, като малък-къс формат. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(2),
    view = <span class="code">new</span> DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1 
	    	</pre></dd>
	    </dl>
	    <p>Този пример използва дву-байтов <em>array buffer</em> за съхраняване на две <em>int8</em> стойности. Първата стойност се определя на <em>set</em> от 0 отместване, а втората с отразяване на отместване 1, като всеки байт е пълен (8 бита). Тези стойности по-късно са извлечени от своите позиции. Докато този пример използва <em>int8</em> стойности, вие може да използвате всеки от осемте цифрови типа със съответните методи. Пълният списък от методи е:</p>
	    <dl>
	    	<dd>
	    		<ul>
	    			<li>getInt8(byteOffset, littleEndian) - read an int8 starting at byteOffset </li>
	    			<li>setInt8(byteOffset, value, littleEndian) - write an int8 starting at byteOffset </li>
	    			<li>getUint8(byteOffset, littleEndian) - read an uint8 starting at byteOffset</li>
	    			<li>setUint8(byteOffset, value, littleEndian) - write an uint8 starting at byteOffset</li>
	    			<li>getInt16(byteOffset, littleEndian) - read an int16 starting at byteOffset</li>
	    			<li>setInt16(byteOffset, value, littleEndian) - write an  int16 starting at byteOffset </li>
	    			<li>getUint16(byteOffset, littleEndian) - read an uint16 starting at byteOffset </li>
	    			<li>setUint16(byteOffset, value, littleEndian) - write an uint16 starting at byteOffset </li>
	    			<li>getInt32(byteOffset, littleEndian) - read an int32 starting at byteOffset </li>
	    			<li>setInt32(byteOffset, value, littleEndian) - write an int32 starting at byteOffset </li>
	    			<li>getUint32(byteOffset, littleEndian) - read an uint32 starting at byteOffset </li>
	    			<li>setUint32(byteOffset, value, littleEndian) - write an uint32 starting at byteOffset </li>
	    			<li>getFloat32(byteOffset, littleEndian) - read a float32 starting at byteOffset </li>
	    			<li>setFloat32(byteOffset, value, littleEndian) - write a float32 starting at byteOffset </li>
	    			<li>getFloat64(byteOffset, littleEndian) - read a float64 starting at byteOffset </li>
	    			<li>setFloat64(byteOffset, value, littlebEndian) - write a float64 starting at byteOffset </li>
	    		</ul>
	    	</dd>
	    </dl>
	    <p>Най-интересния аспект на <em>views</em> е, че може да чете и пише във всякакъв формат във всяка точа във времето, независимо от това, как са се съхранявали данните преди това. Например, какво ще стане ако запишем две <em>int8</em> стойности, а буфера ги чете, като <em>int16</em>? Това работи добре, както в този пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(2),
    view = <span class="code">new</span> DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt16(0));      // 1535
console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1
	    	</pre></dd>
	    </dl>
	    <p>Извикването на <em>view.getInt16(0)</em> чете всички байтове във <em>view</em> и интерпретира тези байтове, като номер 1535. За да разберем защо това се случва, да разгледаме, какво прави всеки ред в <em>array buffer</em>.</p>
	    <dl>
	    	<dd>
	    		<p>new ArrayBuffer(2)&nbsp; &nbsp; &nbsp; &nbsp;0000000000000000</p>
	    		<p>view.setInt8(0, 5);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000010100000000</p>
	    		<p>view.setInt8(1, -1);&nbsp; &nbsp; &nbsp; &nbsp;0000010111111111</p>
	    	</dd>
	    </dl>
	    <p><em>Array buffer</em> започва с 16 бита, които са нули. Добавянето на <em>int8</em> със стойност 5 от началото на <em>array buffer</em> въвежда двойки единици с 8-битово представяне (00000101). Когато е написано -1 за втори байт, тя настройва всички битове на едно (два допълват представянето). В края <em>array buffer</em> съдържа 16 бита, които след това ще прочете, като 16-битово цяло число използвайки <em>getInt16()</em>. Тълкуването на тези 16-бита, като един номер е 1535.</p>
	    <p><em>DataView</em> обекта е идеален за случаи на употреба, когато се смесват различни типове данни по този начин. Обаче, ако използвате само един определен тип данни, тогава типа <em>views</em> е по-добрия избор</p>
	    <h3>Специфични типове Views</h3>
	    <p>ECMAScript 6 <em>typed arrays</em> са всъщност специфичните за типа <me>views</em> за <em>array buffer</em>. Вместо да използвате общ <em>DataView обект</em> за да оперирате на <em>array buffer</em>, можете да използвате обекти, които налагат определени типове данни. Има девет специфични типа <em>views</em>, съответстващи на осем цифрови данни плюс един допълнителен по избор за <em>uint8</em> стойности. В следващата таблица е съкратения вариант на едно, намерено в спецификацията (раздел 22.2)  и списъци на различните видове:</p>
	 <dl>
	  	<dd> <table class="table">
	  	<tr>
	  		<th>Constructor Name</th>
	  		<th>Element<br>Size</th>
	  		<th>Description</th>
	  		<th >Equivalent <br>C Type</th>
	  	</tr>
	  	<tr>
	  		<td >Int8Array</td>
	  		<td >1</td>
	  		<td>8-bit 2’s <br> complement <br>signed <br> integer</td>
	  		<td>signed <br>char</td>
	  	</tr>
	  	<tr>
	  		<td>Uint8Array</td>
	  		<td>1</td>
	  		<td>8-bit <br>unsigned <br>integer</td>
	  		<td>unsigned <br> char</td>
	  	</tr>
	  	<tr>
	  		<td>Uint8ClampedArray</td>
	  		<td>1</td>
	  		<td>8-bit <br> unsigned <br> integer <br>(clamped <br>conversion)</td>
	  		<td>unsigned <br>char</td>
	  	</tr>
	  	<tr>
	  		<td>Int16Array</td>
	  		<td>2</td>
	  		<td>16-bit 2’s <br> complement <br>signed <br>integer </td>
	  		<td>short</td>
	  	</tr>
	  	<tr>
	  		<td>Uint16Array</td>
	  		<td>2</td>
	  		<td>16-bit <br>unsigned <br>integer</td>
	  		<td>unsigned <br>short</td>
	  	</tr>
	  	<tr>
	  		<td>Int32Array</td>
	  		<td>4</td>
	  		<td>32-bit 2’s <br> complement <br>signed <br>integer</td>
	  		<td>int</td>
	  	</tr>
	  	<tr>
	  		<td>Uint32Array</td>
	  		<td>4</td>
	  		<td>32-bit <br>unsigned <br>integer <br>unsigned</td>
	  		<td>int</td>
	  	</tr>
	  	<tr>
	  		<td>Float32Array</td>
	  		<td>4</td>
	  		<td>32-bit IEEE <br>floating <br>point</td>
	  		<td>float</td>
	  	</tr>
	  	<tr>
	  		<td>Float64Array</td>
	  		<td>8</td>
	  		<td>64-bit IEEE <br>floating <br>point</td>
	  		<td>double</td>
	  	</tr>
	  </table></dd>
	  </dl>
	  <p><em>Uint8ClampedArray</em> е същата, като <em>Uint8Array</em>, освен когато стойностите са по-малки от 0 и по-големи от 255. В този случай <em>Uint8ClampedArray</em> ще конвертира стойности по-ниски от 0 на 0 (-1 ще стане 0, например) и стойности по-големи от 255 на 255 (300 ще стане 255, например).</p>
	  <p>Всеки от въведените масиви ограничава операциите да работят върху определен тип данни, така всички операции на <em>Int8Array</em> използват <em>int8</em> стойности. Това означава, че всеки <em>typed array</em> също има размер на разликата - байт на елемент. Като се има в предвид, че <em>Int8Array</em> има елемент на байт, <em>Float64Array</em> използва осем байта за елемент. Елементите са достъпни, чрез цифрови индекси, точно както редовни масиви, което позволява да се избегне до някъде неудобното повикване на “set” и“get” методите на <em>DataView</em>.</p>
	  <dl>
	  	<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Докато <em>typed arrays</em> изглеждат и се държат подобно на JavaScript масивите, те не наследяват от <em>Array</em>.</strong></dd>
	  </dl>
	  <h3>Създаване на специфични типове Views</h3>
	  <p>Конструктора на <em>typed arrays</em> приема множество различни видове аргументи.  Първо, можем да създадем нов вид масив, като подадем същите аргументи, както бихме направили за <em>DataView</em>, което означава, <em>array buffer</em>, незадължителен байт за отместване и незадължителен байт дължина.</p>
	  <dl>
	  	<dd><pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view1 = <span class="code">new</span> Int8Array(buffer),
    view2 = <span class="code">new</span> Int8Array(buffer, 5, 2);

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
	  	</pre></dd>
	  </dl>
	  <p>В този код, двата <em>views</em> са двете <em>UInt8Array</em> инстанции, които използват <em>buffer</em>. И двата <em>view1</em> и <em>view2</em> имат същия <em>buffer, byteOffset</em> и <em>byteLength</em> свойства, които съществуват на <em>DataView</em> инстанции. Лесна е размяната в използването на <em>typed array</em> всеки път, когато използвате <em>DataView</em> толкова дълго, колкото ви се работи само с един цифров тип.</p>
	  <p>Вторият начин за създаване на <em>typed array</em> е да се подаде един номер към конструктора. Този номер представлява броя на елементите (не байтове) за отпускане на масива. По този начин, конструктора създава нов буфер, който има правилния брой байтове за представяне на броя на елементите на масива. След това можем да получим достъп до броя на елементите в масива с помощта на свойството <em>length</em>. Например:</p>
	  <dl>
	  	<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(2),
    floats = <span class="code">new</span> Float32Array(5);

console.log(ints.byteLength);       // 4
console.log(ints.length);           // 2

console.log(floats.byteLength);     // 20
console.log(floats.length);         // 5
	  	</pre></dd>
	  </dl>
	  <p>Създадения <em>ints</em> масив има два елемента. Всяко 16-битово цяло число изисква два байта на стойност, така масива е разделен на четири байта. Създадения <em>floats</em> масив има пет елемента, така броят на необходимите байтове е 20 (четири байта на елемент). И в двата случая е създаден нов буфер и може да бъде достъпен, използвайки <em>buffer</em> свойството ако е необходимо.</p>
	  <dl>
	  	<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Ако не се подава никакъв аргумент към конструктора на печатния масив, конструктора действа, като че е подадена 0. Това ефективно създава <em>typed array</em>, който не може да побере никакви данни, защото 0 байта са разпределени на буфера. </strong></dd>
	  </dl>
	  <div class="aside">
	  <h3>Размер на елемент</h3>
	  <p>Всеки <em>typed array</em> се състои от няколко елемента и размерът на елементите е броят на байтовете, които представляват всеки елемент. Тази стойност се съхранява в BYTES_PER_ELEMENT свойството на всеки конструктор и за всеки отделен случай, така че лесно можем да дадем заявка за размера на елемента.</p>
	  <pre class="highlight">
console.log(UInt8Array.BYTES_PER_ELEMENT);    // 1
console.log(UInt16Array.BYTES_PER_ELEMENT);   // 2

<span class="code">let</span> ints = <span class="code">new</span> Int8Array(5);
console.log(ints.BYTES_PER_ELEMENT);          // 1
	  	</pre>
	  </div>
	  <p>Третият начин за създаване на <em>typed array</em> е да подадем един обект, като единствен аргумент на конструктора. Обекта може да бъде някой от следните:</p>
	  <dl>
	  	<dd>
	  		<ul>
	  			<li><strong>Typed Array </strong>- всеки елемент се копира в нов елемент на нов <em>typed array</em> (например, <em>int8</em> се копира в <em>int16</em>). Новият <em>typed array</em>  има различен <em>array buffer</em> от този, който му е подаден.</li>
	  			<li><strong>Iterable</strong>- итератора се извиква за да извлече елементите и да ги вмъкне в <em>typed array</em>. Конструктора ще хвърли грешка ако някой от елементите е невалиден за типа.</li>
	  			<li><strong>Array</strong>- елементите на масива се копират в нов <em>typed array</em>. Конструктора ще хвърли грешка ако някой от елементите е невалиден за типа.</li>
	  			<li><strong>Array-Like Object </strong>- държи се по същия начин, като <em>array</em>.</li>
	  		</ul>
	  	</dd>
	  </dl>
	  <p>Във всеки то тези случаи, нов <em>typed array</em> е създаден с данните от обекта източник. Това може да бъде особено полезно, когато искате да инициализирате <em>typed array</em> с някои стойности, като например:</p>
	  <dl>
	  	<dd><pre class="highlight">
<span class="code">let</span> ints1 = <span class="code">new</span> Int16Array([25, 50]),
    ints2 = <span class="code">new</span> Int32Array(ints1);

console.log(ints1.buffer === ints2.buffer);     // false

console.log(ints1.byteLength);      // 4
console.log(ints1.length);          // 2
console.log(ints1[0]);              // 25
console.log(ints1[1]);              // 50

console.log(ints2.byteLength);      // 8
console.log(ints2.length);          // 2
console.log(ints2[0]);              // 25
console.log(ints2[1]);              // 50
	  	</pre></dd>
	  </dl>
	  <p>Този пример създава <em>Int16Array</em> и го инициализира с масив от две стойности. След това, се създава <em>Int32Array</em> и му се подава <em>Int16Array</em>. Стойностите 25 и 50 са копирани от <em>ints1</em> в <em>ints2</em>, като двата <em>typed arrays</em> имат съвсем отделни буфери. Същите номера са представени в двата <em>typed arrays</em>, но <em>ints2</em> има осем байта за представяне на данните, докато <em>ints1</em> има само четири.</p>
	  <h3>Прилики с масиви</h3>
	  <p>Както вече видяхте, <em>typed arrays</em> могат да бъдат използвани, като редовни масиви в много ситуации. Можем да видим, колко елемента са в масива използвайки <em>length</em> свойство и можем да получим достъп до елементите директно с помощта на цифровите индекси, като например:</p>
	  <dl>
	  	<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[0] = 1;
ints[1] = 2;

console.log(ints[0]);              // 1
console.log(ints[1]);              // 2
	  	</pre></dd>
	  </dl>
	  <p>В този пример, се създава нов <em>Int16Array</em> с два елемента. Елементите се четат и пишат, като се използват техните цифрови индекси и тези стойности автоматично се съхраняват и конвертират в <em>int16</em> стoйности, като част от операцията.</p>
	  <p><em>Тyped arrays</em> също са сходни с редовните масиви, поради наличието на голям брой методи за масиви. Това са методите за масиви, които може да използвате за <em>typed arrays</em>:</p>
	  <dl>
	   				<dd>
	   					<ul>
	   						<li><strong>copyWithin()</strong> - копира стойностите на масив от самия масив, започвайки от целата до края на масива.</li>
	   						<li><strong>fill()</strong> - замества всички елементи на масива от началния до крайния индекс със статична стойност.</li>
	   						<li><strong>filter()</strong> - създава нов масив с всички елементи,които преминават теста испълняван от тестващата функция.</li>
	   						<li><strong>find()</strong> - връща стойноста от масива, ако елемента отговаря на тестващата функция.</li>
	   						<li><strong>findIndex()</strong> - връща индекса от масива, ако елемента отговаря на тестващата функция.</li>
	   						<li><strong>forEach()</strong> - извиква подадената функция последоватлено поведнъж за всеки елемент в масива.</li>
	   						<li><strong>indexOf()</strong> - връща първия индекс, при който даден елемент е намерен в масива или -1, ако не е намерен.</li>
	   						<li><strong>join()</strong> - обединява всички елементи на масива в <em>string</em>.</li>
	   						<li><strong>keys()</strong> - връща нов масив <em>iterator</em>, който съдържа ключове за всеки индекс на масива.</li>
	   						<li><strong>lastIndexOf()</strong> - връща последния индекс, в който даден елемент е намерени в масива или -1, ако не е намерен.</li>
	   						<li><strong>map()</strong> -  връща нов масив с резултатите от условието на функцията за всеки елемент от масива.</li>
	   						<li><strong>reduce()</strong> - прилага функция върху всяка стойност в масив от ляво на дясно, за да сведе масива до една единствена стойност.</li>
	   						<li><strong>reduceRight()</strong> - прилага функция върху всяка стойност в масив от дясно на ляво, за да сведе масива до една единствена стойност.</li>
	   						<li><strong>reverse()</strong> - обръща масив на място.</li>
	   						<li><strong>slice()</strong> - връща повърхностно копие на част от масив в нов масив обект.</li>
	   						<li><strong>some()</strong> - тества дали някои елемент в масива преминава теста, на предоставената функция.</li>
	   						<li><strong>sort()</strong> - сортира елементите на масив на място и връща масив.</li>
	   						<li><strong>values()</strong> - връща нов масив <em>iterator</em> обект, който съдържа стойностите за всеки индекс на масива.</li>
	   					</ul>
	   				</dd>
	   			</dl> 
	<p>Имайте в предвид, че докато всички тези методи действат също, както тези на <em>Array.prototype</em>, те не са едни и същи методи. Методите на <em>typed arrays</em> имат допълнителни проверки за безопасност за цифров тип и когато се връща масив, ще се върне един <em>typed array</em> вместо редовен масив. Ето един прост пример:</p>
	<dl>
	   	<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    mapped = ints.map(v => v * 2);

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 50
console.log(mapped[1]);            // 100

console.log(mapped <span class="code">instanceof</span> Int16Array);  // true
	   	</pre></dd>
	</dl>
	<p>Този пример използва <em>map()</em> метод за създаване на нов масив базиран на стойности от <em>ints. Mapping</em> функцията удвоява всяка стойност в масива и връща нова в <em>Int16Array</em>.</p>
	<p>Имайте в предвид, че <em>typed arrays</em> имат същите три итератора, както редовните масиви: <em>entries(), keys()</em> и <em>values()</em>. Те позволяват използването на <em>spread</em> оператора и <em>for-of</em> цикъла по същия начин, както бихме направили с редовни масиви. Например:</p>
	    <dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    intsArray = [...ints];

console.log(intsArray <span class="code">instanceof Array</span>);    // true
console.log(intsArray[0]);                  // 25
console.log(intsArray[1]);                  // 50
			</pre></dd>
		</dl>	
		<p>Този код създава нов масив <em>intsArray</em> съдържащ същите данни, както <em>typed array</em> <em>ints</em>. Както и при другите <em>iterables</em>, оператора <em>spread</em> е един лесен начин за конвертиране на <em>typed arrays</em> в редовни.</p>
		<p>Накрая, всички <em>typed arrays</em> имат статичните методи <em>of()</em> и <em>from()</em>, които работят по същия начин, както <em>Array.of()</em> и <em>Array.from()</em>. Единствената разлика е, че резултата е в пчатен масив вместо в реален масив. В противен случай можете да използвате, тези методи по същия начин, за да създадете различни <em>typed arrays</em>, като например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = Int16Array.of(25, 50),
    floats = Float32Array.from([1.5, 2.5]);

console.log(ints <span class="code">instanceof</span> Int16Array);        // true
console.log(floats <span class="code">instanceof</span> Float32Array);    // true

console.log(ints.length);       // 2
console.log(ints[0]);           // 25
console.log(ints[1]);           // 50

console.log(floats.length);     // 2
console.log(floats[0]);         // 1.5
console.log(floats[1]);         // 2.5
			</pre></dd>
		</dl>
		<p>Методите <em>of()</em> и <em>from()</em> се използват за създаване на <em>Int16Array</em> и <em>Float32Array</em>. Тези методи гарантират, че <em>typed arrays</em> могат да бъдат създадени също толкова лесно, колкото редовните масиви.</p>
		<h3>Разлики с Arrays</h3>
		<p>Най-значимата разлика между <em>typed arrays</em> и редовни масиви е, <em>typed arrays</em> не са редовни масиви. Това означава, че те не наследяват от <em>Array</em> и <em>Array.isArray()</em> връща <em>false</em>, когато се подаде на <em>typed array</em>. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints <span class="code">instanceof Array</span>);     // false
console.log(<span class="code">Array</span>.isArray(ints));       // false
			</pre></dd>
		</dl>
		<p>Променливата <em>ints</em> е <em>typed array</em>, така че не е инстанция на <em>Array</em> и не може да бъде идентификатор на масив. Това разграничение е важно, защото има много начини, по които <em>typed arrays</em> не се държат, като редовни масиви.</p>
		<p>Като се има в предвид, че редовните масиви могат да растат и свиват при взаимодействие с тях, <em>typed arrays</em> винаги остават със същия размер. Също така, не можем да присвоим стойност на несъществуващ цифров индекс, както можем с редовни масиви, защото печатния масив ще игнорира операцията. Ето един пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[2] = 5;

console.log(ints.length);          // 2
console.log(ints[2]);              // undefined
			</pre></dd>
		</dl>
		<p>Въпреки присвояването на цифровия индекс 2 в този пример, <em>ints</em> масива не расте изобщо. Дължината остава същата и стойността се изхвърля.</p>
		<p><em>Тyped arrays</em> също имат проверки, за да се гарантира, че се използват само валидни типове данни. Нулата се използва вместо всички невалидни стойности. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(["hi"]);

console.log(ints.length);       // 1
console.log(ints[0]);           // 0
			</pre></dd>
		</dl>
		<p>Този код се опитва да използва <em>string</em> стойността "hi" в <em>Int16Array</em>. Разбира се, <em>strings</em> са невалиден тип данни в <em>typed arrays</em>, така че се въвежда нула вместо стойността. Дължината на масива остава същата и <em>ints[0]</em> съществува, като е запълнен с нула вместо със <em>string</em>. Същото ограничение се прилага за всички методи, които променят стойностите в <em>typed array</em>. Например, ако функцията се подаде към <em>map()</em>, той връща невалидна стойност за <em>typed array</em>, след това използва нула за отговор:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    mapped = ints.map(v => "hi");

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 0
console.log(mapped[1]);            // 0

console.log(mapped <span class="code">instanceof</span> Int16Array);  // true
console.log(mapped <span class="code">instanceof Array</span>);       // false
			</pre></dd>
		</dl>
		<p>Тъй като, <em>string</em> стойността "hi" използва 16-битово цяло число, то се заменя с 0 в получения масив. Всички методи на масиви имат подобно поведение за коригиране на грешки, за да се избегне хвърлянето на грешки, когато са налице невалидни данни.</p>
		<p>Последната разлика между <em>typed arrays</em> и редовни масиви, е че в <em>typed arrays</em> липсват няколко метода за масиви. Следните методи не са на разположение в <em>typed arrays</em>:</p>
		<dl>
			<dd>
				<ul>
					<li><strong>concat()</strong> - връща нов масив, който се състои от други масиви с техните стойности, като аргументи.</li>
					<li><strong>pop()</strong> - премахва последния елемент от масив и връща този елемент.</li>
					<li><strong>push()</strong> - добавя един или повече елементи в края на масивa и връща нов масив.</li>
					<li><strong>shift()</strong> - премахва първият елемент от масив и връща този елемент. Този метод променя дължината на масива.</li>
					<li><strong>splice()</strong> - променя съдържанието на масив чрез премахване на съществуващи елементи и/или добавя нови елементи.</li>
					<li><strong>unshift()</strong> - добавя един или повече елементи в началото на масива и връща нов масив.</li>
				</ul>
			</dd>
		</dl>
		<p>С изключение на <em>concat()</em>, другите методи могат да променят размера на масив и така не са достъпни за <em>typed arrays</em> (тъй като те не могат да променят размера си). Метода <em>concat()</em> не е достъпен, тъй като не е ясно за резултата, какво ще конкатенира в два <em>typed arrays</em>, особено ако те се занимават с данни от различни типове.</p>
		<h3>Допълнителни методи</h3>
		<p>Има няколко метода за <em>typed arrays</em>, които не присъстват в редовните масиви: <em>set()</em> и <em>subarray()</em>. Тези два метода са противоположни, <em>set()</em> позволява копиране на друг масив в съществуващ <em>typed array</em>, докато <em>subarray()</em> извлича част от съществуващ <em>typed array</em> в нов <em>typed array</em>.</p>
	    <p>Метода <em>set()</em> приема масив (било печатен или редовен) и по избор отместване, при което да въвежда данните (по подразбиране е нула). Данните от масива-аргумент се копират в дестинацията на <em>typed array</em>, като същевременно се гарантира, че се използват само валидни типове данни. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(4);

ints.set([25, 50]);
ints.set([75, 100], 2);

console.log(ints.toString());   // 25,50,75,100
	    	</pre></dd>
	    </dl>
	    <p>Този код създава <em>Int16Array</em> с четири елемента. Първото извикване на <em>set()</em> копира две стойности на първия и втория елемент в масива. Второто извикване на <em>set()</em> използва отместване с 2 за да покаже, че стойностите трябва бъдат поставени в масива, започвайки от третия елемент.</p>
	    <p>Докато <em>set()</em> въвежда нови стойности в <em>typed array</em>, то <em>subarray()</em> извлича стойности от нов <em>typed array</em>. Метода <em>subarray()</em> приема по избор начален и краен индекс (с крайния индекс включително, както в <em>slice()</em> метода) и връща нов <em>typed array</em>. Можем също така да пропуснем двата аргумента, за да създадем клонинг на <em>typed array</em>. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50, 75, 100]),
    subints1 = ints.subarray(),
    subints2 = ints.subarray(2),
    subints3 = ints.subarray(1, 3);

console.log(subints1.toString());   // 25,50,75,100
console.log(subints2.toString());   // 75,100
console.log(subints3.toString());   // 50,75
	    	</pre></dd>
	    </dl>
	    <p>Тука са три <em>typed arrays</em>, създадени от първоначалния <em>ints</em> масив в този пример. Масива <em>subints1</em> е клонинг на <em>ints</em>, съдържащ цялата съща информация. Масива <em>subints2</em> започва да копира данни от индекс 2 и съдържа само последните два елемента на масива (75 и 100).  Масива <em>subints3</em> съдържа елементите в средата на <em>ints</em> масива, тъй като и двата аргумента бяха използвани от <em>subarray()</em>.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>ECMAScript 6 продължава работата на ECMAScript 5, като продължава да актуализира и променя масивите, за да бъдат по-полезни. Сега има два нови начина за създаване на масиви <em>Array.of()</em> и <em>Array.from()</em>. Тези методи могат да се използват за създаване на масиви, като в случай на <em>Array.from()</em>, да конвертира <em>iterables</em> и масиво-подобни обекти в масиви. И двата метода са наследени от производните класове на масиви и използват <em>Symbol.species</em> свойството за да се определи, какъв тип стойност трябва да върнат.</p>
		<p>Има и няколко нови метода за масиви. Методите <em>fill()</em> и <em>copyWithin()</em> позволяват да променяме масив на място. Методите <em>find()</em> и <em>findIndex()</em> са полезни за намиране на първия елемент в масив, който съвпада с дадени критерии. Първият връща първият елемент, който отговаря на критериите, а последния връща индекса, в който е намерен елемента.</p>
		<p><em>Тyped arrays</em> всъщност не са масиви, тъй като не наследяват от <em>Array</em>, но изглеждат и се държат, като масиви. <em>Тyped arrays</em> съдържат един от осемте различни типа цифрови данни и са изградени върху <em>ArrayBuffer</em> обекти, които предоставят основно битове за номер или поредица от номера. <em>Typed arrays</em>са по-ефективен начин за правене на пробитова аритметика, защото стойностите не се конвертират напред и назад между форматите, както се случва с типовете номера в JavaScript.</p>
	</footer>
	<nav>
	<a href="09_classes.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="11_promises.html" title="next chapter">▶</a>
</nav>
</body>
</html>