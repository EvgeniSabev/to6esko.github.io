<!DOCTYPE html>
<!-- saved from url=(0043)./19_paint.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Project: A Paint Program :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 19;var sandboxLoadFiles = ["code/chapter/19_paint.js"];</script>
</head>

<body><article>
<nav>
  <a href="./18_forms.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./20_node.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 19</div>Проект: програма за рисуване</h1>
<blockquote>
<p><a class="p_ident" id="p_YcWG8HTlFz" href="./19_paint.html#p_YcWG8HTlFz"></a>Виждам много цветове пред мен. Гледам своето празно платно. След това се опитвам да прилагам цветовете, също както думите оформят поеми, също както нотите оформят музика.”</p>
 <footer>Joan Miro</footer>
</blockquote>
<p><a class="p_ident" id="p_4VGZtxD2xS" href="./19_paint.html#p_4VGZtxD2xS"></a>Материалът от предишната глава дава всички елементи, които ни трябват за да се изгради просто уеб приложение. В тази глава ние ще направим точно това.</p>
<p><a class="p_ident" id="p_1emWaHj7VO" href="./19_paint.html#p_1emWaHj7VO"></a>Нашето приложение ще бъде уеб-базирана програма за рисуване, по подобие на Microsoft Paint. Можете да го използвате за да отворите файлове с изображения и освен това да рисувате върху тях с мишката. Ето как ще изглежда: </p>
<div class="image">
  <img src="./media/paint.png" alt="A simple paint program">
</div>
<p><a class="p_ident" id="p_oDwL9FxPW8" href="./19_paint.html#p_oDwL9FxPW8"></a>Рисуването върху компютър е велико. Не е нужно да се притесняваме за материали, умения или талант. Просто направете цапаница.</p>
<h2><a class="h_ident" id="h_h4HWFf13vp" href="./19_paint.html#h_h4HWFf13vp"></a>Изпълнение</h2>
<p><a class="p_ident" id="p_JoMqYLSjLp" href="./19_paint.html#p_JoMqYLSjLp"></a>Интерфейса за програмата за рисуване, показва голям <code>&lt;canvas&gt;</code> елемент с голям брой полета на форми под него. Потребителя рисува върху картината, като избира инструмент от <code>&lt;select&gt;</code> полето и след това щракне или плъзне върху платното. Има инструменти за рисуване на лини, за изтриване на части от картината, добавяне на текст и т. н.</p>
<p><a class="p_ident" id="p_f2FunmZ+W/" href="./19_paint.html#p_f2FunmZ+W/"></a>Кликването върху платното ще оставим в ръцете на <code>"mousedown"</code> събитието за текущо избрания инструмент, който може да се обработва в зависимост от това, кой начин ще изберем. Рисуващият линия инструмент, например, ще се ослушва за <code>"mousemove"</code> събитие, докато бутона на мишката е свободен и ще чертае линии по пътя на мишката използвайки текущия цвят и размер на четка.</p>
<p><a class="p_ident" id="p_SidGjlM9I+" href="./19_paint.html#p_SidGjlM9I+"></a>Цвета и размера на четката се избират с допълнителни полета на формуляра. Те са закачени в контекста на <code>fillStyle</code>, <code>strokeStyle</code> и <code>lineWidth</code>, които актуализират платното за рисуване, винаги, когато те се променят.</p>
<p><a class="p_ident" id="p_ARTBoP4NDe" href="./19_paint.html#p_ARTBoP4NDe"></a>Можете да заредите изображение в програмата по два начина. Първият използва поле на файл, където потребителя може да избере файл от своята файлова система. Вторият пита за URL и ще донесе изображение от уеб.</p>
<p><a class="p_ident" id="p_7b82pMSl8A" href="./19_paint.html#p_7b82pMSl8A"></a>Изображенията се запазват по-малко по-нетипичен начин, с линк Save долу в дясно на текущото изображение. Те може да се следват, споделят и запазват. Ще обясня, как става това по-късно.</p>
<h2><a class="h_ident" id="h_9CGBdyKskt" href="./19_paint.html#h_9CGBdyKskt"></a>Изграждане  на  DOM</h2>
<p><a class="p_ident" id="p_sqg53vjc6x" href="./19_paint.html#p_sqg53vjc6x"></a>Интерфейса на нашата програма е изграден с повече от 30 DOM елемента. Това трябва да се изгради по някакъв начин.</p>
<p><a class="p_ident" id="p_BwXcOEgv2v" href="./19_paint.html#p_BwXcOEgv2v"></a>HTML е най-очевидният формат за дефиниране на сложни структури на DOM. Но разделянето на програмата на парчета от HTML и скрипт е затруднено от факта, че много от DOM елементите се нуждаят обработка на събитие или да бъдат манипулирани от скрипта по някакъв друг начин. По този начин, на нашия скрипт ще се налижи да прави много <code>querySelector</code> (или подобни) за да намира и призовава DOM елементите, от които има нужда за да работи.</p>
<p><a class="p_ident" id="p_hwJVTRpgY3" href="./19_paint.html#p_hwJVTRpgY3"></a>Би било хубаво, ако структурата на DOM за всяка част от нашия интерфейс е дефиниран в близост до кода на JavaScript, който да го управлява. Поради тази причина, аз избрах да направя всичко по създаването на DOM разклонения вътре в JavaScript. Както видяхме в <a href="./13_dom.html#standard">Глава 13</a>, вградения интерфейс за изграждане на структура на DOM е ужасно многословен. Ако ще правим много голяма структура на DOM се нуждаем от помощна функция.</p>
<p><a class="p_ident" id="p_7sINQE+0xU" href="./19_paint.html#p_7sINQE+0xU"></a>Тази помощна функция е разширена версия на <code>elt</code> функцията от <a href="./13_dom.html#elt">Глава 13</a>. Тя създава един елемент давайки му име и атрибути  и му добавя всички допълнителни аргументи, които той получава, като разклонения на деца, автоматично преобразуване на <em>strings</em> в текст разклонения. </p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_adN9+1mjk9" href="./19_paint.html#c_adN9+1mjk9"></a><span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">attributes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">attr</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">attributes</span>)
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">attr</span>))
        <span class="cm-variable-2">node</span>.<span class="cm-property">setAttribute</span>(<span class="cm-variable-2">attr</span>, <span class="cm-variable-2">attributes</span>[<span class="cm-variable-2">attr</span>]);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">child</span> <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">==</span> <span class="cm-string">"string"</span>)
      <span class="cm-variable-2">child</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>);
    <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>;
}</pre>
<p><a class="p_ident" id="p_ulZXM8Og9d" href="./19_paint.html#p_ulZXM8Og9d"></a>Това ни позволява да създаваме елементи лесно, без да прави нашия изходен код дълъг и скучен, като договор на корпорация с краен потребител.</p>
<h2><a class="h_ident" id="h_feJq2F1dmk" href="./19_paint.html#h_feJq2F1dmk"></a>Фондацията</h2>
<p><a class="p_ident" id="p_fc9fUQEVHE" href="./19_paint.html#p_fc9fUQEVHE"></a>В основата на нашата програма е <code>createPaint</code> функцията, която добавя интерфейс за рисуване на DOM елемент даден, като аргумент. Понеже искаме да изградим нашата програма  парче по парче, ние определяме един обект, наречен <code>controls</code>, който ще съдържа функции за инициализиране на различните видове управления под изображението.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_8HViSwekFi" href="./19_paint.html#c_8HViSwekFi"></a><span class="cm-keyword">var</span> <span class="cm-variable">controls</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">createPaint</span>(<span class="cm-def">parent</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"canvas"</span>, {<span class="cm-property">width</span>: <span class="cm-number">500</span>, <span class="cm-property">height</span>: <span class="cm-number">300</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">toolbar</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-property">class</span>: <span class="cm-string">"toolbar"</span>});
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">controls</span>)
    <span class="cm-variable-2">toolbar</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">controls</span>[<span class="cm-variable-2">name</span>](<span class="cm-variable-2">cx</span>));

  <span class="cm-keyword">var</span> <span class="cm-def">panel</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-property">class</span>: <span class="cm-string">"picturepanel"</span>}, <span class="cm-variable-2">canvas</span>);
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">panel</span>, <span class="cm-variable-2">toolbar</span>));
}</pre>
<p><a class="p_ident" id="p_vEXvH0x+Tb" href="./19_paint.html#p_vEXvH0x+Tb"></a>Всяко управление има достъп до контекста на платното за рисуване и чрез този контекст - <code>canvas</code> свойство към самия <code>&lt;canvas&gt;</code> елемент. По-голямата част от програмата живее в този <em>canvas</em> - той съдържа текущата картина, както и избрания цвят (в <code>fillStyle</code> свойство) и размера на четката (в <code>lineWidth</code> свойство).</p>
<p><a class="p_ident" id="p_p0cg1HO335" href="./19_paint.html#p_p0cg1HO335"></a>Ние ще увием платното и управлението в <code>&lt;div&gt;</code> елементи с класове, така че да можем да добавим малко <code>style</code>, като сива рамка около картината.</p>
<h2><a class="h_ident" id="h_dgOsN5kwO8" href="./19_paint.html#h_dgOsN5kwO8"></a>Избор  на  инструменти</h2>
<p><a class="p_ident" id="p_g0nRLu/Vl9" href="./19_paint.html#p_g0nRLu/Vl9"></a>На първото управление добавяме <code>&lt;select&gt;</code> елемент, който позволява на потребителя да вземе инструмент за рисуване. Както с <code>controls</code> ние ще използваме  обект за събиране на различни инструменти, така че няма да ги кодираме на едно място, а ще добавим повечето инструменти по-късно. Този обект свързва имената на инструментите с функция, която трябва да се извика, когато те се избират и платното е кликнато.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_6ReIFCisw3" href="./19_paint.html#c_6ReIFCisw3"></a><span class="cm-keyword">var</span> <span class="cm-variable">tools</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">controls</span>.<span class="cm-property">tool</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">tools</span>)
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">name</span>));

  <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">tools</span>[<span class="cm-variable-2">select</span>.<span class="cm-property">value</span>](<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>);
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Tool: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p><a class="p_ident" id="p_8di1zX3Jlb" href="./19_paint.html#p_8di1zX3Jlb"></a>Полето с инструментите е населено с <code>&lt;option&gt;</code> елементи за всички инструменти, които са определени и манипулатора <code>"mousedown"</code> на елемента на платното се грижи за извикване на функцията за текущия инструмент, подавайки и обекта на събитието и контекста на рисуването, като аргументи. Тя също извиква 
<code>preventDefault</code>, така че задържането на бутона на мишката и влаченето не кара браузъра да избира части от страницата.</p>
<p><a class="p_ident" id="p_C/kPVzLbL1" href="./19_paint.html#p_C/kPVzLbL1"></a>Най-основния инструмент е за линия, който позволява на потребителя да чертае линии с мишката. За да накараме линията да свършва на правилното място, ние трябва да сме в състояние да намерим относителните координати на платното, където дадено събитие съответства на мишката. Метода <code>getBoundingClientRect</code> на кратко споменат в <a href="./13_dom.html#boundingRect">Глава 13</a>, може да ни помогне тука. Той ни казва къде е показан елемент спрямо горния ляв ъгъл на екрана. Свойствата <code>clientX</code> и <code>clientY</code> на мишката също са свързани с този ъгъл, така че можем да извадим горния ляв ъгъл на платното от тях за да получим позиция по отношение на този ъгъл.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_y+L1e9IlNG" href="./19_paint.html#c_y+L1e9IlNG"></a><span class="cm-keyword">function</span> <span class="cm-variable">relativePos</span>(<span class="cm-def">event</span>, <span class="cm-def">element</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">element</span>.<span class="cm-property">getBoundingClientRect</span>();
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">left</span>),
          <span class="cm-property">y</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientY</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">top</span>)};
}</pre>
<p><a class="p_ident" id="p_GsfGlWhhEu" href="./19_paint.html#p_GsfGlWhhEu"></a>Няколко от инструментите за рисуване трябва да се ослушват за <code>"mousemove"</code> събития, докато бутона на мишката е задържан натиснат. Функцията <code>trackDrag</code> се грижи за регистрирането и отрегистрирането на такива ситуации.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_bAQGH1X5W9" href="./19_paint.html#c_bAQGH1X5W9"></a><span class="cm-keyword">function</span> <span class="cm-variable">trackDrag</span>(<span class="cm-def">onMove</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">end</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">onEnd</span>)
      <span class="cm-variable-2">onEnd</span>(<span class="cm-variable-2">event</span>);
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
}</pre>
<p><a class="p_ident" id="p_wDVSXmBYxk" href="./19_paint.html#p_wDVSXmBYxk"></a>Тази функция взема два аргумента. Единия е функция, която се извиква за всяко <code>"mousemove"</code> събитие, а другия е функция, която се извиква, когато бутона на мишката е свободен. Всеки от тези  аргументи  може да се пропусне ако е необходимо.</p>
<p><a class="p_ident" id="p_QF1cI/MERi" href="./19_paint.html#p_QF1cI/MERi"></a>Инструментът за линията използва тези два помощника да правят действителния чертеж.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_zQjCDnLrcv" href="./19_paint.html#c_zQjCDnLrcv"></a><span class="cm-variable">tools</span>.<span class="cm-property">Line</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">lineCap</span> <span class="cm-operator">=</span> <span class="cm-string">"round"</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable-2">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">stroke</span>();
  }, <span class="cm-variable-2">onEnd</span>);
};</pre>
<p><a class="p_ident" id="p_WgxKzx/dih" href="./19_paint.html#p_WgxKzx/dih"></a>Функцията започва с определяне на контекста на чертежа със свойството <code>lineCap</code> на <code>"round"</code>, което причинява двата края на очертанията на пътя да са заоблени, а не с квадратна форма по подразбиране. Това е трик за да се уверим, че множеството отделни линии изготвени в отговор на отделни събития, изглеждат, като една съгласувана линия. При по-големи широки линии, вие ще видите пропуски в ъглите, ако използвате обикновени линии по подразбиране.</p>
<p><a class="p_ident" id="p_AQy4O9XOrj" href="./19_paint.html#p_AQy4O9XOrj"></a>После за всяко <code>"mousemove"</code> събитие, което се случва докато бутона на мишката е натиснат, се чертае отсечка прекарана между старата и новата позиция на мишката, като се използва някой от определените в момента случаи, като <code>strokeStyle</code> или <code>lineWidth</code>.</p>
<p><a class="p_ident" id="p_LdZL7msldK" href="./19_paint.html#p_LdZL7msldK"></a><code>onEnd</code> аргумента на <code>tools.Line</code> просто се подава през <code>trackDrag</code>. Нормалният начин за стартиране на инструмент не изисква подаване на трети аргумент, за това при използването на инструмента за линия, този аргумент ще доведе до 
<code>undefined</code> и нищо няма да се случи в края на драгването на мишката. Аргумента е там за да ни позволи  прилагането на функцията за изтриване на върха на инструмента за линия с много малко допълнителен код.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_A8FTE3sfhc" href="./19_paint.html#c_A8FTE3sfhc"></a><span class="cm-variable">tools</span>.<span class="cm-property">Erase</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"destination-out"</span>;
  <span class="cm-variable">tools</span>.<span class="cm-property">Line</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"source-over"</span>;
  });
};</pre>
<p><a class="p_ident" id="p_0Apcf0lbn3" href="./19_paint.html#p_0Apcf0lbn3"></a>Свойството <code>globalCompositeOperation</code> влияе на начина на операциите за рисуване върху платното, като променя цвета на пикселите, които се допират. По подразбиране стойността на свойството е <code>"source-over"</code>, което означава, че рисуваният цвят е насложен върху съществуващия цвят на това място. Ако цвета е непрозрачен, той просто ще замени стария цвят, но ако е полупрозрачен, двата цвята ще бъдат смесени.</p>
<p><a class="p_ident" id="p_+Ckjs7EFIj" href="./19_paint.html#p_+Ckjs7EFIj"></a>Инструмента за изтриване определя <code>globalCompositeOperation</code> да е <code>"destination-out"</code>, което има ефекта за изтриване на пикселите, които се допират, като ги прави прозрачни отново.</p>
<p><a class="p_ident" id="p_RRoUPpuAjO" href="./19_paint.html#p_RRoUPpuAjO"></a>Това ни дава два инструмента в нашата програма за рисуване. Можем да чертаем черни линии един пиксел широки (по подразбиране за <code>strokeStyle</code> и <code>lineWidth</code> върху платното) и да ги изтрием после. Това работи, макар и доста ограничено в програмата за рисуване.</p>
<h2><a class="h_ident" id="h_lIikGuI/QG" href="./19_paint.html#h_lIikGuI/QG"></a>Цвят  и  размер  на  четката</h2>
<p><a class="p_ident" id="p_STY3nzP377" href="./19_paint.html#p_STY3nzP377"></a>Ако потребителите искат да направят други цветове освен черно и да използват различни размери на четката, трябва да добавим управления за тези две настройки.</p>
<p><a class="p_ident" id="p_Iq68Mq2ClK" href="./19_paint.html#p_Iq68Mq2ClK"></a>В <a href="./18_forms.html#forms">Глава 18</a> обсъдихме различни полета на формуляри. Но цветни полета не бяха сред тях. Традиционно браузъра не разполага с вградена поддръжка за цветови колектори, но в последните няколко години редица типове полета на форми са стандартизирани. Един от тях е <code>&lt;input type="color"&gt;</code>, други са <code>"date"</code>, <code>"email"</code>, <code>"url"</code> и <code>"number"</code>. Не всички браузъри ги подкрепят все още - по време на това писане, никаква версия на Internet Explorer не поддържа цветни полета. Типа по подразбиране на <code>&lt;input&gt;</code> тага е <code>"text"</code> и когато се използва неподдържан тип, браузъра ще го третира, като текстово поле. Това означава, че потребителите, които работят на Internet Explorer с нашата програма за рисуване, ще трябва да въвеждат името на цвета, който искат, а не да го избират от удобна джаджа.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_876pZkfMUC" href="./19_paint.html#c_876pZkfMUC"></a><span class="cm-variable">controls</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"color"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Color: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p><a class="p_ident" id="p_nNIuUTzgwz" href="./19_paint.html#p_nNIuUTzgwz"></a>Всеки път, когато стойността на цвета на полето се промени, контекста на рисуване с <code>fillStyle</code> и <code>strokeStyle</code> се актуализира, за да подкрепи новата стойност.</p>
<p><a class="p_ident" id="p_C0Hqixv9pV" href="./19_paint.html#p_C0Hqixv9pV"></a>Полето за конфигуриране размера на четката работи по същия начин.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_cTEY1f58II" href="./19_paint.html#c_cTEY1f58II"></a><span class="cm-variable">controls</span>.<span class="cm-property">brushSize</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">sizes</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">8</span>, <span class="cm-number">12</span>, <span class="cm-number">25</span>, <span class="cm-number">35</span>, <span class="cm-number">50</span>, <span class="cm-number">75</span>, <span class="cm-number">100</span>];
  <span class="cm-variable-2">sizes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">size</span>) {
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, {<span class="cm-property">value</span>: <span class="cm-variable-2">size</span>},
                           <span class="cm-variable-2">size</span> <span class="cm-operator">+</span> <span class="cm-string">" pixels"</span>));
  });
  <span class="cm-variable-2">select</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">select</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Brush size: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p><a class="p_ident" id="p_qOGqGx5+Pr" href="./19_paint.html#p_qOGqGx5+Pr"></a>Кодът генерира възможности от масив за размери на четката и отново гарантира, че <code>lineWidth</code> на платното се актуализира, когато е избран размер на четката.</p>
<h2><a class="h_ident" id="h_NpxTTfNE7h" href="./19_paint.html#h_NpxTTfNE7h"></a>Запазването</h2>
<p><a class="p_ident" id="p_7TUivCYbPO" href="./19_paint.html#p_7TUivCYbPO"></a>За да се обясни изпълнението на линка <em>Save</em>, първо трябва да ви разкажа за URL адреса на данните. URL адрес на данни е URL с данни: като негов протокол. За разлика от обикновените <em>http:</em> и <em>https:</em> URL адреси, URL данните не сочат ресурс, а по-скоро съдържат целия ресурс в тях. Това са URL данни, съдържащи един прост HTML документ:</p>
<pre>data:text/html,&lt;h1 style="color:red"&gt;Hello!&lt;/h1&gt;</pre>
<p><a class="p_ident" id="p_eWZrRGYvaj" href="./19_paint.html#p_eWZrRGYvaj"></a>URL адресите на данни са полезни за различни задачи, като включително малки изображения директно в <code>style</code> файл. Те също така ни позволяват да се свържем към файловете, които създадохме от страна на клиента в браузъра, без да се налага първо да ги местим на някой сървър.</p>
<p><a class="p_ident" id="p_Wcu43CMIZj" href="./19_paint.html#p_Wcu43CMIZj"></a>Елементите на платното имат удобен метод, наречен <code>toDataURL</code>, който ще върне на URL данни, които съдържа картината на платното, като графичен файл. Ние не искаме да актуализираме нашия линк Save всеки път, когато картината се променя, обаче. За големи картини, които включват преместване на доста данни в линка, ще бъде забележимо бавно. Вместо това ще пригодим линка да актуализира своя <code>href</code> атрибут, когато е фокусиран с клавиатурата или мишката преместена върху него.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_azFCqdr7Bk" href="./19_paint.html#c_azFCqdr7Bk"></a><span class="cm-variable">controls</span>.<span class="cm-property">save</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"a"</span>, {<span class="cm-property">href</span>: <span class="cm-string">"/"</span>}, <span class="cm-string">"Save"</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">update</span>() {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">toDataURL</span>();
    } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">SecurityError</span>)
        <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-string">"javascript:alert("</span> <span class="cm-operator">+</span>
          <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-string">"Can't save: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>.<span class="cm-property">toString</span>()) <span class="cm-operator">+</span> <span class="cm-string">")"</span>;
      <span class="cm-keyword">else</span>
        <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseover"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"focus"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">link</span>;
};</pre>
<p><a class="p_ident" id="p_FK9LTdpkC3" href="./19_paint.html#p_FK9LTdpkC3"></a>По този начин връзката просто си седи тихо там, сочейки нещо погрешно, но когато потребителя подходи към нея, тя магически се актуализира, за да се отбележи в настоящата картина.</p>
<p><a class="p_ident" id="p_fvaHWlCaUS" href="./19_paint.html#p_fvaHWlCaUS"></a>Ако заредим голям образ, някои браузъри ще се задавят с гигантски URL данни, който линка произвежда. За малки картини, този подход работи без проблем.</p>
<p><a class="p_ident" id="p_yj2JNpVbGr" href="./19_paint.html#p_yj2JNpVbGr"></a>Но тука отново се впускаме в тънкостите на тестовата среда на браузъра. Когато изображението е заредено от URL на друг домейн, ако отговора на сървъра не включва кауза, която да казва на браузъра, че ресурса може да се използва от друг домейн (виж <a href="./17_http.html#http_sandbox">Глава 17</a>), тогава платното ще може да съдържа информация, която потребителя може да вижда, но скрипта да не може.</p>
<p><a class="p_ident" id="p_P2fyJXYkeA" href="./19_paint.html#p_P2fyJXYkeA"></a>Ние може да поискаме изображение, което съдържа лична информация (на пример, графика на салдото от потребителска сметка) използвайки потребителската сесия. Ако скриптовете могат да получат информация от това изображение, те биха могли да се ровят в данните на потребителя по нежелателен начин.</p>
<p><a class="p_ident" id="p_OHFwilBG6F" href="./19_paint.html#p_OHFwilBG6F"></a>За да предотвратим този вид изтичане на информация, браузъра ще отбележи платното, като заразено, когато изображението, което скрипта не може да види се рисува върху него. Пиксел данни, включително URL данни не могат да бъдат извлечени от заразено платно. Можем да пишем върху него, но не можем да го прочетем.</p>
<p><a class="p_ident" id="p_40OvqfoZJr" href="./19_paint.html#p_40OvqfoZJr"></a>Ето защо се нуждаем от <code>try/catch</code> изявлението в <code>update</code> функцията за линка Save. Когато платното се превърне в заразено, извиквайки <code>toDataURL</code> ще повдигне изключение, като инстанция на <code>SecurityError</code>. Когато това се случи, ние ще създадем връзка към точката на още един вид URL, използвайки <em>javascript:</em> протокол. Тази връзка изпълнява просто скрипта даден след двуточието, която следвайки този линк ще се покаже <code>alert</code> прозорец информирайки потребителя за проблема, когато се натисне.</p>
<h2><a class="h_ident" id="h_iQAMmIQaWl" href="./19_paint.html#h_iQAMmIQaWl"></a>Зареждане  на  файлове  с  изображения</h2>
<p><a class="p_ident" id="p_3vrUSpPAL9" href="./19_paint.html#p_3vrUSpPAL9"></a>Последните две управления се използват за прехвърляне на изображения от локални файлове и от URL адреси. Ще имаме нужда от следната помощна функция, която се опитва да зареди файл с изображение от URL и да замени съдържанието на платното с него.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_pOA1CgtG03" href="./19_paint.html#c_pOA1CgtG03"></a><span class="cm-keyword">function</span> <span class="cm-variable">loadImageURL</span>(<span class="cm-def">cx</span>, <span class="cm-def">url</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable-2">image</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">color</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span>, <span class="cm-def">size</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">width</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">height</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable-2">image</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">size</span>;
  });
  <span class="cm-variable-2">image</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-variable-2">url</span>;
}</pre>
<p><a class="p_ident" id="p_fxJmZUi/g3" href="./19_paint.html#p_fxJmZUi/g3"></a>Ние искаме да променим размера на платното, за да отговаря на изображението. По някаква причина, променяната на размера на платното ще предизвика неговия контекст за рисуване да забрави конфигурационните свойства, като <code>fillStyle</code> и <code>lineWidth</code>, така че функцията ще ги запази и възстанови, след като актуализира размера на платното.</p>
<p><a class="p_ident" id="p_BRkDNREP7P" href="./19_paint.html#p_BRkDNREP7P"></a>Управлението за зареждане на локален файл използва <code>FileReader</code> техниката от <a href="./18_forms.html#filereader">Глава 18</a>. Отделно от <code>readAsText</code> метода, който използвахме там, такива четящи обекти също имат метод наречен <code>readAsDataURL</code>, което е точно това, което ни трябва тук. Ние зареждаме файла, който потребителя е избрал като URL данни и го предаваме на <code>loadImageURL</code> да го пусне в платното.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_lXjE/XfP0W" href="./19_paint.html#c_lXjE/XfP0W"></a><span class="cm-variable">controls</span>.<span class="cm-property">openFile</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"file"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">reader</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">FileReader</span>();
    <span class="cm-variable-2">reader</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">reader</span>.<span class="cm-property">result</span>);
    });
    <span class="cm-variable-2">reader</span>.<span class="cm-property">readAsDataURL</span>(<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>[<span class="cm-number">0</span>]);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Open file: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p><a class="p_ident" id="p_3cQw/osn6v" href="./19_paint.html#p_3cQw/osn6v"></a>Зареждането на файл от URL дори е по-лесно. Но с текстово поле, то е по-малко ясно, кога потребителя приключва с писането на URL, така че не можем просто да се ослушваме за <code>"change"</code> събития. Вместо това, ще увием полето във форма, която да реагира при подаване на формуляра, когато потребителя натисне Enter или е кликнал върху бутона за зареждане.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_XY31yVKH8e" href="./19_paint.html#c_XY31yVKH8e"></a><span class="cm-variable">controls</span>.<span class="cm-property">openURL</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"text"</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">form</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"form"</span>, <span class="cm-atom">null</span>,
                 <span class="cm-string">"Open URL: "</span>, <span class="cm-variable-2">input</span>,
                 <span class="cm-variable">elt</span>(<span class="cm-string">"button"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"submit"</span>}, <span class="cm-string">"load"</span>));
  <span class="cm-variable-2">form</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"submit"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">form</span>;
};</pre>
<p><a class="p_ident" id="p_kU0DSJWhbC" href="./19_paint.html#p_kU0DSJWhbC"></a>Сега сме определили всички управления, от които нашата проста програма за рисуване се нуждае, но тя може да използва още няколко инструмента.</p>
<h2><a class="h_ident" id="h_COOrE3GQwB" href="./19_paint.html#h_COOrE3GQwB"></a>Довършване  на  горе</h2>
<p><a class="p_ident" id="p_eRxkqfyNnx" href="./19_paint.html#p_eRxkqfyNnx"></a>Можем лесно да добавим инструмент за текст, който използва <code>prompt</code>, за да пита потребителя, какъв <em>string</em> трябва да направи.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_8/T9PP3cBg" href="./19_paint.html#c_8/T9PP3cBg"></a><span class="cm-variable">tools</span>.<span class="cm-property">Text</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">"Text:"</span>, <span class="cm-string">""</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">text</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">7</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>) <span class="cm-operator">+</span> <span class="cm-string">"px sans-serif"</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-variable-2">text</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  }
};</pre>
<p><a class="p_ident" id="p_L3dnKFwhJy" href="./19_paint.html#p_L3dnKFwhJy"></a>Можем да добавим допълнителни полета за размера и стила на шрифта, но за улеснение ще използваме винаги <em>sans-serif</em>  шрифт и за основа на размера на шрифта, текущия размер на четката. Минималния размер е 7 пиксела, защото текст по-малък от този е нечетлив.</p>
<p><a class="p_ident" id="p_rTc/MzJCFC" href="./19_paint.html#p_rTc/MzJCFC"></a>Друг незаменим инструмент за рисуване на аматьорска компютърна графика е спрея за боя. Той рисува точки в рамките на случайни места под четката, стига мишката да е задържана натисната, създавайки плътно или по-малко плътно пръскане въз основа на това колко бързо или бавно се движи мишката.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_MPtJObrL+v" href="./19_paint.html#c_MPtJObrL+v"></a><span class="cm-variable">tools</span>.<span class="cm-property">Spray</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">radius</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">area</span> <span class="cm-operator">=</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">dotsPerTick</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">area</span> <span class="cm-operator">/</span> <span class="cm-number">30</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">spray</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">dotsPerTick</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">offset</span> <span class="cm-operator">=</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-variable-2">radius</span>);
      <span class="cm-variable-2">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-variable-2">currentPos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">x</span>,
                  <span class="cm-variable-2">currentPos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
    }
  }, <span class="cm-number">25</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  }, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable-2">spray</span>);
  });
};</pre>
<p><a class="p_ident" id="p_PC1+gUob8b" href="./19_paint.html#p_PC1+gUob8b"></a>Инструмента за спрей използва <code>setInterval</code> за да изплюе цветни точици на всеки 25 милисекунди, докато бутона на мишката е задържан натиснат. Функцията <code>trackDrag</code> се използва за да запази <code>currentPos</code>, която показва текущата позиция на мишката и да изключи интервала, когато бутона на мишката е освободен.</p>
<p><a class="p_ident" id="p_CRD18th69E" href="./19_paint.html#p_CRD18th69E"></a>За да се определи, колко точки се правят всеки път при ефекта на интервала, функцията изчислява площта на текущата четка и я разделя на 30. За да намерим случайна позиция под четката използваме  функцията <code>randomPointInRadius</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_yPBoJqnTXO" href="./19_paint.html#c_yPBoJqnTXO"></a><span class="cm-keyword">function</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">for</span> (;;) {
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">1</span>)
      <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>, <span class="cm-property">y</span>: <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>};
  }
}</pre>
<p><a class="p_ident" id="p_bpIPMJAN/Q" href="./19_paint.html#p_bpIPMJAN/Q"></a>Тази функция генерира точки в квадрат между (-1, -1) и (1, 1). И с помощта на Питагоровата теорема, проверява дали образуваните точки лежат в кръг с радиус от 1. Веднага след, като функцията установи такава точка, тя връща точката умножена по <code>radius</code> аргумента.</p>
<p><a class="p_ident" id="p_8ATK7SQccV" href="./19_paint.html#p_8ATK7SQccV"></a>Цикъла е необходим за по-равномерно разпределение на точките. Друг разбираем начин за генериране на случайна точка във вътрешноста на кръг е да се използва случаен ъгъл и разстояние и извикване на <code>Math.sin</code> и <code>Math.cos</code> да създадат съответната точка. Но с този метод, точките са по-склонни да се появяват в близост до центъра на кръга. Има и други начини за това, но те са по-сложни.</p>
<p><a class="p_ident" id="p_Tj66LpaWji" href="./19_paint.html#p_Tj66LpaWji"></a>Сега имаме една функционираща програма за рисуване. Стартирайте кода по долу, за да я изпробвате.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_pD0giwc4AL" href="./19_paint.html#c_pD0giwc4AL"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./19_paint.html#h_TcUD2vzyMe"></a>Упражнения </h2>
<p><a class="p_ident" id="p_We+KsAI00v" href="./19_paint.html#p_We+KsAI00v"></a>Все още има много място за подобрения в тази програма. Нека добавим още няколко функции, като упражнения.</p>
<h3><a class="h_ident" id="h_AXnJJyTV3X" href="./19_paint.html#h_AXnJJyTV3X"></a>Правоъгълници</h3>
<p><a class="p_ident" id="p_4pYKvTwVL6" href="./19_paint.html#p_4pYKvTwVL6"></a>Дефинирайте инструмент наречен <code>Rectangle</code> който запълва правоъгълник (виж <code>fillRect</code> метода в <a href="./16_canvas.html#fill_stroke">Глава 16</a>) с текущия цвят. Правоъгълника трябва да обхваща от точката, където потребителя натисне бутона на мишката до точката, където го освобождава. Имайте в предвид, че последното може да бъде над или в ляво от първото.</p>
<p><a class="p_ident" id="p_FZYD7EtH2K" href="./19_paint.html#p_FZYD7EtH2K"></a>След като той работи, вие ще забележите, че до известна степен дразни, като не се вижда правоъгълника, когато влачите мишката за да определите своя размер. Можете ли да измислите начин за показване на модела на правоъгълника по време на драгването без да го рисувате всъщност на платното, докато бутона на мишката се освободи?</p>
<p><a class="p_ident" id="p_XS+oeSzbgP" href="./19_paint.html#p_XS+oeSzbgP"></a>Ако нищо не ви идва на ум се върнете на <code>position: absolute</code> стила обсъден в <a href="./13_dom.html#animation">Chapter 13</a>, който може да се използва  за наслагване на разклонения върху останалата част от документа. Свойствата <code>pageX</code> и <code>pageY</code> на събитието на мишката могат да бъдат използвани, за позициониране на елемент точно под мишката, чрез определяне на <code>left</code>, <code>top</code>, <code>width</code> и <code>height</code> стилове към правилните пикселни стойности.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_dL4pxdAiRT" href="./19_paint.html#c_dL4pxdAiRT"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>.<span class="cm-property">Rectangle</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_+2Q554eAdQ" href="./19_paint.html#p_+2Q554eAdQ"></a>Можете да използвате <code>relativePos</code> за да намерите ъгъл, съответстващ на началото на плъзгане на мишката. Измислянето на това, къде свършва влаченето, може да бъде направено с <code>trackDrag</code> или като регистрирате свой собствен манипулатор на събитие.</p>
<p><a class="p_ident" id="p_UvlqG2Ephm" href="./19_paint.html#p_UvlqG2Ephm"></a>Когато имате два ъгъла на правоъгълника, трябва по някакъв начин да превърнете това в аргументи, които <code>fillRect</code> очаква:  горния ляв ъгъл, ширина и височина на правоъгълника. <code>Math.min</code> може да се използва за да намерите най-левия х-координата и най-гориния у-координата. За да получите ширината и височината, можете да ползвате <code>Math.abs</code> (абсолютната стойност) върху разликата между двете страни.</p>
<p><a class="p_ident" id="p_qnwnWqJZmQ" href="./19_paint.html#p_qnwnWqJZmQ"></a>Показването на правоъгълника по време на плъзгане на мишката изисква подобен набор от числа, но в контекста на цялата страница, а не по отношение на платното. Помислете за написване на функция <code>findRect</code>, която преобразува две точки в обект с <code>top</code>, <code>left</code>, <code>width</code> и <code>height</code> свойства, така че да не е нужно да се пише една и съща логика два пъти.</p>
<p><a class="p_ident" id="p_BtWgOio6fw" href="./19_paint.html#p_BtWgOio6fw"></a>След това можете да създадете <code>&lt;div&gt;</code> разклонение и настроите <code>style.position</code>: <code>absolute</code>. При определяне на стилове за позициониране, не забравяйте да добавите <code>"px"</code> към номерата. Разклонението трябва да се добавя към документа (може да го добавите с <code>document.body</code>, както и да го отстраните) отново, когато влаченето завърши и действителния правоъгълник се изготви върху платното.</p>
</div></div>
<h3><a class="h_ident" id="h_kd7pYrPaOx" href="./19_paint.html#h_kd7pYrPaOx"></a>Избор на цвят</h3>
<p><a class="p_ident" id="p_Jg9zx2ZHXs" href="./19_paint.html#p_Jg9zx2ZHXs"></a>Друг инструмент, който се среща често в графичните програми е колектор за цвят, който позволява  на потребителя, като кликне върху изображението да опредли цвета под показалеца на мишката. Изградете това.</p>
<p><a class="p_ident" id="p_2/ActRBD9m" href="./19_paint.html#p_2/ActRBD9m"></a>За тази услуга се нуждаем от начин за достъп до съдържанието на платното. Метода <code>toDataURL</code> повече или по-малко е направил това, но вземането на пиксел-информация от такъв URL с данни е трудно. Вместо това, използвайте метода <code>getImageData</code> в контекста на рисуването, който връща правоъгълно парче с изображение, като обект с <code>width</code>, <code>height</code>,
и <code>data</code> свойства. Свойството <code>data</code> притежава масив с числа от 0 до 255, като се използват четири числа  за представяне на червено, зелено, синьо и алфа компонента (прозрачност) за всеки пиксел.</p>
<p><a class="p_ident" id="p_D6jTExt5KG" href="./19_paint.html#p_D6jTExt5KG"></a>Този пример извлича цифрите за един пиксел от платното веднъж, когато платното е празно (всички пиксели са прозрачно черни) и веднъж, когато пикселът е оцветен в червено. </p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_kkpvQb4tko" href="./19_paint.html#c_kkpvQb4tko"></a><span class="cm-keyword">function</span> <span class="cm-variable">pixelAt</span>(<span class="cm-def">cx</span>, <span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">getImageData</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">data</span>.<span class="cm-property">data</span>);
}

<span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [0, 0, 0, 0]</span>

<span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
<span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [255, 0, 0, 255]</span></pre>
<p><a class="p_ident" id="p_LAAk4BgbLG" href="./19_paint.html#p_LAAk4BgbLG"></a>Аргументите на <code>getImageData</code> показват началните х и у - координати на правоъгълника, който искаме да обработим, последвани от неговата ширина и височина..</p>
<p><a class="p_ident" id="p_C46YeilKO0" href="./19_paint.html#p_C46YeilKO0"></a>Игнорирайте прозрачността по време на това упражнение и вижте само първите три стойности за даден пиксел. Също така не се притеснявайте за актуализирането на цветовете на полето, когато потребителя избира цвят. Просто се уверете, че контекста за рисуване на <code>fillStyle</code> и <code>strokeStyle</code> е настроен на цвета под курсора на мишката.</p>
<p><a class="p_ident" id="p_AvBU/YxtZc" href="./19_paint.html#p_AvBU/YxtZc"></a>Не забравяйте, че тези свойства приемат всеки цвят, който CSS разбира, което включва <code>rgb(R, G, B)</code> стила, който видяхме в <a href="./15_game.html#game_css">Глава 15</a>.</p>
<p><a class="p_ident" id="p_TrX1yewkGx" href="./19_paint.html#p_TrX1yewkGx"></a>Метода <code>getImageData</code> е субект на същите ограничения, както <code>toDataURL</code> - той ще повдигне грешка, когато платното съдържа пиксели, които произхождат от друг домейн. Използвайте <code>try/catch</code> изявление, за да докладвате такива грешки в диалоговия прозорец <code>alert</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_tIbJS0qHIa" href="./19_paint.html#c_tIbJS0qHIa"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>[<span class="cm-string">"Pick color"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_VIyP7gKCWe" href="./19_paint.html#p_VIyP7gKCWe"></a>Отново ще трябва да ползвате <code>relativePos</code>, за да разберете кой пиксел е кликнат. Функцията <code>pixelAt</code> в примера показва, как да получите стойностите на един пиксел. Поставянето им в един <code>rgb</code> <em>string</em> просто изисква конкатенация на <em>strings</em>.</p>
<p><a class="p_ident" id="p_F8sDaqW/ce" href="./19_paint.html#p_F8sDaqW/ce"></a>Уверете се, че проверката за изключение е инстанция на <code>SecurityError</code>, така че да не се справяте случайно с грешен вид изключение.</p>
</div></div>
<h3><a class="h_ident" id="h_0M49T26QUl" href="./19_paint.html#h_0M49T26QUl"></a>Наводнение</h3>
<p><a class="p_ident" id="p_9+5Lhu8/5P" href="./19_paint.html#p_9+5Lhu8/5P"></a>Това упражнение е за по-напреднали, отколкото предните две и ще изисква да се изработи <em>nontrivial</em> решение на сложен проблем. Уверете се, че имате достатъчно търпение и време, преди да започнете да работите върху него и не се обезсърчавайте от първите неуспехи.</p>
<p><a class="p_ident" id="p_OkFYhhueP3" href="./19_paint.html#p_OkFYhhueP3"></a>Наводнението е инструмент за запълване на цветове на пиксели под мишката и околните пиксели с един и същи цвят. За целите на това упражнение, обмислете такава група за включване на всички пиксели, които могат да бъдат достигнати от нашия начален пиксел чрез преместване със стъпка един пиксел хоризонтално и вертикално (без диагонал), без да докосваме пиксела, който има различен цвят от началния пиксел.</p>
<p><a class="p_ident" id="p_6uRENk52k1" href="./19_paint.html#p_6uRENk52k1"></a>Следното изображение илюстрира набор от оцветени пиксели, когато инструмента за наводнение се използва с маркирания пиксел.</p>
<div class="image">
  <img src="./media/flood-grid.svg" alt="Flood fill example">
</div>
<p><a class="p_ident" id="p_wwglcJ4sDv" href="./19_paint.html#p_wwglcJ4sDv"></a>Наводнението не изтича през диагоналните пропуски и не докосва пикселите, които не са достъпни, дори да имат същия цвят, като целевия пиксел.</p>
<p><a class="p_ident" id="p_76DZCicyt0" href="./19_paint.html#p_76DZCicyt0"></a>Вие отново ще трябва да разберете цвета на всеки пиксел с <code>getImageData</code>. Може би е добра идея да се извлече цялото изображение на един път и след това да изберете пиксел данни от получения масив. Пикселите са организирани в този масив по начин подобен на елементите на мрежата в <a href="./07_elife.html#grid">Глава 7</a>, по един ред в даден момент с изключение на това, че всеки пиксел е представен от четири стойности. Първата стойност на пиксела е (<em>x</em>, <em>y</em>) в позиция (<em>x</em> + <em>y</em> × width) × 4.</p>
<p><a class="p_ident" id="p_jVploHhiTC" href="./19_paint.html#p_jVploHhiTC"></a>Необходимо е включването на четвърта (алфа) стойност, тъй като искаме да бъдем в състояние да кажем разликата между празни и черни пиксели.</p>
<p><a class="p_ident" id="p_pGlySQoufy" href="./19_paint.html#p_pGlySQoufy"></a>Намирането на всички съседни пиксели със същия цвят изисква от вас “разходка” над повърхността на пикселите, един нагоре, надолу, наляво и надясно, докато новите същия цвят пиксели бъдат намерени. Но вие няма да намерите всички пиксели от една група с първата разходка. По-скоро трябва да направите нещо подобно на връщане назад, извършено с регулярен израз за съвпадение, описано в <a href="./09_regexp.html#backtracking">Глава 9</a>. Когато има повече от една възможна посока, за да продължите, трябва да запишете всички посоки, които не се вземат веднага и да ги прегледате по-късно, когато приключите текущата разходка.</p>
<p><a class="p_ident" id="p_QgadJ7T7nC" href="./19_paint.html#p_QgadJ7T7nC"></a>В едно нормално по-големина изображение има много пиксели. За това, вие трябва да се погрижите да се извършва необходимото минимално количество работа или програмата ще отнеме много дълго време да се изпълнява. Например всяка разходка трябва да игнорира пиксела видян от предишните разходки, така че да не се повтаря вече свършената работа.</p>
<p><a class="p_ident" id="p_tPAU+iaccT" href="./19_paint.html#p_tPAU+iaccT"></a>Аз препоръчвам да извикате <code>fillRect</code> за отделните пиксели, когато един пиксел, който трябва да бъде оцветен е намерен и запазите някаква структура от данни, която ви казва за всички пиксели, които вече са били разгледани.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Cj2ssFLWyJ" href="./19_paint.html#c_Cj2ssFLWyJ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>[<span class="cm-string">"Flood fill"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_roLPCOzlbR" href="./19_paint.html#p_roLPCOzlbR"></a>При дадена двойка начални координати и данните за изображението върху цялото платно, този подход трябва да работи с:</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p><a class="p_ident" id="p_DJfuZAPd2V" href="./19_paint.html#p_DJfuZAPd2V"></a>
Създаване на масив, който да държи информация за вече оцветени координати.
</p>
</li>
<li>
<p><a class="p_ident" id="p_8q76RzMUPC" href="./19_paint.html#p_8q76RzMUPC"></a>
Създаване на масив - работен списък, който да държи координати, които трябва да бъдат разгледани. Поставете начална позиция в него.
</p>
</li>
<li>
<p><a class="p_ident" id="p_jf/y0a21iq" href="./19_paint.html#p_jf/y0a21iq"></a>
Когато работния списък е празен, ние сме готови.
</p>
</li>
<li>
<p><a class="p_ident" id="p_JXeW3M6LBu" href="./19_paint.html#p_JXeW3M6LBu"></a>
Премахнете една двойка координати от работния списък.
</p>
</li>
<li>
<p><a class="p_ident" id="p_ybLJYGmnPS" href="./19_paint.html#p_ybLJYGmnPS"></a>
Ако тези координати са вече в нашия масив от цветни пиксели, се върнете към стъпка 3.
</p>
</li>
<li>
<p><a class="p_ident" id="p_6sixhBP7gV" href="./19_paint.html#p_6sixhBP7gV"></a>
Вземете цвета на пиксела в текущите координати и добавете координатите към масива от цветни пиксели.
</p>
</li>
<li>
<p><a class="p_ident" id="p_37aWwfOEWf" href="./19_paint.html#p_37aWwfOEWf"></a>
Добавяне на координатите на всеки съседен пиксел, чийто цвят е същия, като оригиналния цвят на началния пиксел, към работния списък.
</p>
</li>
<li>
  <p>Върнете се към стъпка 3.</p>
</li>
</ol></div>
<p><a class="p_ident" id="p_K10R222PDR" href="./19_paint.html#p_K10R222PDR"></a>Работния списък може да бъде просто масив от векторни обекти. Структурата от данни, която проследява цветните пиксели ще бъде консултирана много често. Търсенето през цялото това нещо, всеки път, когато нов пиксел се инспектира ще отнеме много време. Вместо това можете да създадете масив, който съдържа стойност за всеки пиксел, отново с помощта на <em>x + y * width</em> схемата, за асоцииране на позиции с пиксели. Когато проверявате дали един пиксел е вече оцветен, вие директно може да получите достъп до позицията съответстваща на текущия пиксел.</p>
<p><a class="p_ident" id="p_238ysWaiXF" href="./19_paint.html#p_238ysWaiXF"></a>Можете да сравните цветовете, чрез преминаване през съответната част от масива с данни, сравнявайки едно поле в даден момент. Или може да "кондензирате" цвят към единично число или <em>string</em> и да го сравните. Когато правите това, трябва да гарантирате, че всеки цвят произвежда уникална стойност. Например, просто добавяне на цветни компоненти не е безопасно, тъй като различни цветове, могат имат една и съща сума.</p>
<p><a class="p_ident" id="p_JPRZIpzUnJ" href="./19_paint.html#p_JPRZIpzUnJ"></a>Когато се изброяват съседите на дадена точка, трябва да се погрижите за изключването на съседи, които не са от вътрешната страна на платното или вашата програма може да избяга в дадена посока завинаги.</p>
</div></div>
<nav>
  <a href="./18_forms.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./20_node.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>