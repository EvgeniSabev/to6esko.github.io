<!DOCTYPE html>
<!-- saved from url=(0044)./09_regexp.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Regular Expressions :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 9;</script>
</head>

<body><article>
<nav>
  <a href="./08_error.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./10_modules.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 9</div>Регулярни изрази</h1>
<blockquote>
<p><a class="p_ident" id="p_MWUwIAb0uO" href="./09_regexp.html#p_MWUwIAb0uO"></a>Някои хора, когато се сблъскат с проблем си мислят „Аз знам, че трябва да използвам регулярни изрази.” Сега те имат два проблема.”</p>
 <footer>Jamie Zawinski</footer>
</blockquote>
<blockquote>
<p><a class="p_ident" id="p_icxlw7+18l" href="./09_regexp.html#p_icxlw7+18l"></a>Ян-ма казал: „Когато сечете едно дърво, е необходима голяма сила. Когато се изправяте срещу проблем, е необходим много код.””</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_81b6macd9j" href="./09_regexp.html#p_81b6macd9j"></a>Програмните инструменти и техники, оцеляват и се разпространяват по хаотичен, еволюционен начин. Те не винаги са красиви и брилянтни, като онези, които функционират достатъчно добре в рамките на правилната ниша - например, като се интегрират с друга успешна част от технология.</p>
<p><a class="p_ident" id="p_2ySNBCvXNS" href="./09_regexp.html#p_2ySNBCvXNS"></a>В тази глава ще обсъдим още един такъв инструмент, <em>regular expressions</em> (регулярни изрази). Регулярните изрази са начин да се пишат модели в <em>string</em> данни. Те образуват един малък, отделен език, който е част от JavaScript и от много други езици и инструменти.</p>
<p><a class="p_ident" id="p_cxbejyPUGl" href="./09_regexp.html#p_cxbejyPUGl"></a>Регулярните изрази са едновременно ужасно неудобни и изключително полезни. Техният синтаксис е загадъчен и програмният интерфейс на JavaScript, предвиден за тях е тромав. Но са мощен инструмент за проверка и обработка на <em>strings</em>. Правилното разбиране на регулярните изрази може да направи един програмист по-ефективен.</p>
<h2><a class="h_ident" id="h_5w4yGFJRYl" href="./09_regexp.html#h_5w4yGFJRYl"></a>Създаване  на  регулярен  израз</h2>
<p><a class="p_ident" id="p_u/9SKAI2Yi" href="./09_regexp.html#p_u/9SKAI2Yi"></a>Регулярният израз е тип обект. Той може да бъде конструиран с <code>RegExp</code> конструктора или  написан, като стойност чрез ограждане на модела с характера за наклонена черта (<code>/</code>).</p>
<pre data-language="javascript" class="snippet cm-s-default"><div class="sandboxhint">edit &amp; run code by clicking it</div><a class="c_ident" id="c_XBSA9s2btm" href="./09_regexp.html#c_XBSA9s2btm"></a><span class="cm-keyword">var</span> <span class="cm-variable">re1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"abc"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">re2</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/</span>;</pre>
<p><a class="p_ident" id="p_uNMQxzr01n" href="./09_regexp.html#p_uNMQxzr01n"></a>И двата регулярни израза представляват един и същ модел: един характер <em>a</em> последван от <em>b</em> последван от <em>c</em>.</p>
<p><a class="p_ident" id="p_qv8UWLVrTv" href="./09_regexp.html#p_qv8UWLVrTv"></a>При използване на конструктора <code>RegExp</code>, моделът е написан, като нормален <em>string</em>, така че се прилагат обичайните правила за обратно наклонените черти.</p>
<p><a class="p_ident" id="p_xB91PDBGKz" href="./09_regexp.html#p_xB91PDBGKz"></a>Втората нотация, където моделът се поставя между наклонени черти, третира  обратно наклонените черти малко по-различно. Първо, тъй като модела завършва с наклонена черта, ние трябва да поставим обратно наклонена черта преди всяка наклонена черта, която искаме да бъде част от модела. В допълнение, обратно наклонените черти, които не са част от специалните характери на кода (като <code>\n</code>) ще бъдат запазени, но няма да им се обърне внимание, тъй като са в <em>strings</em> и променят смисъла на модела. Някои характери, като въпросителен знак и плюс, имат специално значение в регулярните изрази и трябва да бъдат предшествани от обратно наклонена черта, ако са предназначени да представляват себе си.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GMbBpgLwwd" href="./09_regexp.html#c_GMbBpgLwwd"></a><span class="cm-keyword">var</span> <span class="cm-variable">eighteenPlus</span> <span class="cm-operator">=</span> <span class="cm-string-2">/eighteen\+/</span>;</pre>
<p><a class="p_ident" id="p_GYUjU5Z/Gb" href="./09_regexp.html#p_GYUjU5Z/Gb"></a>Знаейки, какво точно прави характера на обратно наклонената черта - <em>escape</em> (бягство) - при писане на регулярни изрази, изисква от вас да знаете всеки характер със специално предназначение. За момента, това не може да бъде реалистично, така че, когато се съмнявате, просто сложете обратно наклонена черта пред всеки характер, който не е буква, цифра или празно пространство.</p>
<h2><a class="h_ident" id="h_vPyyYjMEtz" href="./09_regexp.html#h_vPyyYjMEtz"></a>Тест  за  съвпадение</h2>
<p><a class="p_ident" id="p_0vbMMWCatE" href="./09_regexp.html#p_0vbMMWCatE"></a>Обекта на регулярните изрази има редица методи. Най-простият от тях е <code>test</code>. Ако му подадете <em>string</em>, той ще върне булева стойност, която ви казва дали този <em>string</em> съдържа  съвпадение с модела в израза.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_O53a6v4BM0" href="./09_regexp.html#c_O53a6v4BM0"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abcde"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">"abxde"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_WFokgkkjHh" href="./09_regexp.html#p_WFokgkkjHh"></a>Регулярен израз, съставен само от не-специални характери просто означава поредица от характери. Ние тестваме съвпадението не само в началото и <code>test</code> ще върне <code>true</code>, ако abc е на всякъде в <em>string</em>.</p>
<h2><a class="h_ident" id="h_z4ZvUsIpEG" href="./09_regexp.html#h_z4ZvUsIpEG"></a>Съвпадение на набор от характери</h2>
<p><a class="p_ident" id="p_DtXmb/uhsO" href="./09_regexp.html#p_DtXmb/uhsO"></a>Намирането дали <em>string</em> съдържа <em>abc</em>, може да се направи също толкова добре с извикване на <code>indexOf</code>. Регулярните изрази ни позволяват да отидем отвъд това и да изразят по-сложни модели</p>
<p><a class="p_ident" id="p_i/99SEfu9y" href="./09_regexp.html#p_i/99SEfu9y"></a>Да кажем, че искате съвпадение с всякакви номера. В регулярен израз поставяне на набор от характери между квадратни скоби, прави тази част от израза да съответства на всеки от характерите между скобите.</p>
<p><a class="p_ident" id="p_sC+2E08KnL" href="./09_regexp.html#p_sC+2E08KnL"></a>И двата от следните изрази съответстват на всички <em>strings</em>, които съдържат цифри:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_lup2c3o+xm" href="./09_regexp.html#c_lup2c3o+xm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0123456789]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0-9]/</span>.<span class="cm-property">test</span>(<span class="cm-string">"in 1992"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_i0WYLVUede" href="./09_regexp.html#p_i0WYLVUede"></a>В квадратните скоби, тирето (<code>-</code>) между два характера, може да се използва за указване на диапозон от характери, където редът се определя от Unicode номера за съответния характер. Характерите от 0 до 9 стоят в непосредствена близост един до друг в тази таблица (кодове от 48 до 57), така че <code>[0-9]</code> обхваща всички тях и съответства на всяка цифра.</p>
<p><a class="p_ident" id="p_+w4wbahJfo" href="./09_regexp.html#p_+w4wbahJfo"></a>Има редица общи групи от характери, които имат свои собствени вградени команди за бърз достъп. Цифрите са една от тях: <code>\d</code> означава едно и също нещо, като <code>[0-9]</code>.</p>
<table>
<tbody><tr>
<td><code>\d</code></td>
<td>Всеки характер цифра</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Всеки буквено-цифров характер (‘дума характер’)</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>Всеки характер за празно пространство (space, tab, newline и similar)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>Всеки характер, който не е цифра</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>Всеки не буквено-цифров характер</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>Всеки характер който не е за празно пространство</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Всеки характер, освен характера за нов ред</td>
</tr>
</tbody></table>
<p><a class="p_ident" id="p_yXMUKEYpwG" href="./09_regexp.html#p_yXMUKEYpwG"></a>Така може да откриете съвпаденията за формата на дата и час, например като 30-01-2003 15:20, със следния израз:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vXh+CdcvKs" href="./09_regexp.html#c_vXh+CdcvKs"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-01-2003 15:20"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-jan-2003 15:20"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_NjgwK/FZRp" href="./09_regexp.html#p_NjgwK/FZRp"></a>Това изглежда ужасно, нали? Има прекалено много обратно наклонени черти, които правят фонов шум, което го прави трудно място за действителния модел на израз. Ще видим леко подобрена версия на този израз <a href="./09_regexp.html#date_regexp_counted">по-късно</a>.</p>
<p><a class="p_ident" id="p_P0qAMYu0C/" href="./09_regexp.html#p_P0qAMYu0C/"></a>Тези кодове с обратно наклонена черта могат да бъдат използвани в квадратни скоби. Например <code>[\d.]</code> означава всяка цифра или период от характери. Но имайте в предвид, че самия период, когато се използва в квадратни скоби, губи своето специално значение. Същото важи и за други специални характери, като например плюс <code>+</code>.</p>
<p><a class="p_ident" id="p_HqQEZsitdl" href="./09_regexp.html#p_HqQEZsitdl"></a>За да обърнете набор от характери, тоест искате да съвпадат с всеки характер с изключение на зададените, можете да напишете ксор ^ характер след отварящата скоба.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ExU1Fm09+X" href="./09_regexp.html#c_ExU1Fm09+X"></a><span class="cm-keyword">var</span> <span class="cm-variable">notBinary</span> <span class="cm-operator">=</span> <span class="cm-string-2">/[^01]/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010100110"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">"1100100010200110"</span>));
<span class="cm-comment">// → true</span></pre>
<h2><a class="h_ident" id="h_iFI1qvUwY9" href="./09_regexp.html#h_iFI1qvUwY9"></a>Повтаряне  частите  на  модел</h2>
<p><a class="p_ident" id="p_crYiu/oAUM" href="./09_regexp.html#p_crYiu/oAUM"></a>Вече знаем как да съвпада една цифра. Какво става, ако искаме да съвпада цяла последователност от  една или повече цифри?</p>
<p><a class="p_ident" id="p_B4wupHzbR+" href="./09_regexp.html#p_B4wupHzbR+"></a>Когато поставите харктера плюс (<code>+</code>) след нещо в регулярен израз, това означава, че елемента може да се повтори повече от веднъж. По този начин, <code>/\d+/</code> съвпада с един или повече цифрови характери.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_gPOZZi5uor" href="./09_regexp.html#c_gPOZZi5uor"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"'123'"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">"''"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_/oNBIVm41F" href="./09_regexp.html#p_/oNBIVm41F"></a>Звездата (<code>*</code>) има подобно значение, но също така позволява моделът да съвпада нула пъти. Нещо със звезда след него, никога не предпазва модела от съвпадение - той ще съвпада нула пъти, ако не може да намери подходящ текст за съвпадение.</p>
<p><a class="p_ident" id="p_rtXbvQjQpG" href="./09_regexp.html#p_rtXbvQjQpG"></a>Въпросителният знак прави част от един модел “по избор”, което означава, че може да се случи нула или едно пъти. В следващия пример, на <em>u</em> характера му е позволено да се случи, но модела същто така съвпада и когато липсва.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Jvdrjd3WXF" href="./09_regexp.html#c_Jvdrjd3WXF"></a><span class="cm-keyword">var</span> <span class="cm-variable">neighbor</span> <span class="cm-operator">=</span> <span class="cm-string-2">/neighbou?r/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbour"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">"neighbor"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_B4ikd8xN8i" href="./09_regexp.html#p_B4ikd8xN8i"></a>За да покажете, че един модел трябва да се случва точно брой пъти, използвайте фигурни скоби. Поставянето на <code>{4}</code> след елемент, изисква да се случи точно четири пъти. Възможно е също така да се определи диапазон, по този начин: <code>{2,4}</code> означава, че елемента трябва да се случи най-малко два и най-много четири пъти.</p>
<p id="date_regexp_counted"><a class="p_ident" id="p_awR6bPYROd" href="./09_regexp.html#p_awR6bPYROd"></a>Тука е една версия на модела за дата и час, който позволява и двата - единични и двуцифрени дни, месеци и часове. Също така е по- разбираем.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mwpr5hmR0y" href="./09_regexp.html#c_mwpr5hmR0y"></a><span class="cm-keyword">var</span> <span class="cm-variable">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">"30-1-2003 8:45"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_eVBFhX2vD9" href="./09_regexp.html#p_eVBFhX2vD9"></a>Можете също да определите и отворени граници при използване на фигурни скоби, като не зададете номер от двете страни на запетаята. Така <code>{,5}</code> означава от нула до пет и <code>{5,}</code> означава пет или повече пъти.</p>
<h2><a class="h_ident" id="h_uICSDspz1I" href="./09_regexp.html#h_uICSDspz1I"></a>Групиране  на  под-изрази</h2>
<p><a class="p_ident" id="p_pKTOYUDGIr" href="./09_regexp.html#p_pKTOYUDGIr"></a>За да използвате оператор, като <code>*</code> или <code>+</code> на повече от един елемент в даден момент, може да използвате обикновени скоби. Една част от регулярен израз, който е заграден в скоби се брои за един елемент, доколкото операторите след това са засегнати.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mLfHSPalKV" href="./09_regexp.html#c_mLfHSPalKV"></a><span class="cm-keyword">var</span> <span class="cm-variable">cartoonCrying</span> <span class="cm-operator">=</span> <span class="cm-string-2">/boo+(hoo+)+/i</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cartoonCrying</span>.<span class="cm-property">test</span>(<span class="cm-string">"Boohoooohoohooo"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_S5jkv2dMC+" href="./09_regexp.html#p_S5jkv2dMC+"></a>Първият и вторият характер <code>+</code> се прилагат само за второто <em>o</em> в <em>boo</em> и <em>hoo</em> съответно. Третият <code>+</code> се отнася за цялата група <code>(hoo+)</code> отговаряща на една или повече поредици, като тази.</p>
<p><a class="p_ident" id="p_tFxtn8Pxg1" href="./09_regexp.html#p_tFxtn8Pxg1"></a><code>i</code> в края на израза в предишния пример прави този регулярен израз да се влияе от случая, което позволява да съвпада с главна буква <em>B</em> във входящия <em>string</em>, въпреки, че моделът е само за малки букви. </p>
<h2><a class="h_ident" id="h_CV5XL/TADP" href="./09_regexp.html#h_CV5XL/TADP"></a>Съвпадения и групи</h2>
<p><a class="p_ident" id="p_K4AlKPLvyA" href="./09_regexp.html#p_K4AlKPLvyA"></a>Метода <code>test</code> е абсолютно най-простия начин за съответствие с регулярен израз. Той ви казва само дали съвпада и нищо друго. Регулярните изрази имат също и <code>exec</code> метод, който ще върне <code>null</code> ако не е открито съвпадение или в противен случай ще върне обект с информация за съвпадението.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_YvQYsEnL/O" href="./09_regexp.html#c_YvQYsEnL/O"></a><span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"one two 100"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>);
<span class="cm-comment">// → ["100"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 8</span></pre>
<p><a class="p_ident" id="p_fJSwbQyG6w" href="./09_regexp.html#p_fJSwbQyG6w"></a>Обекта, който се връща от <code>exec</code> има свойството <code>index</code>, което ни казва, къде в string успешно започва съвпадението. Освен това, обекта изглежда, като масив от <em>strings</em> (и всъщност е), чиито първи елемент е <em>string</em>-а, който съответства - в предишния пример, това е последователноста от цифри, която тръсехме.</p>
<p><a class="p_ident" id="p_VT4fpht7D7" href="./09_regexp.html#p_VT4fpht7D7"></a><em>String</em> стойностите имат <code>match</code> метод, който се държи по подобен начин.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yvsDvKWBej" href="./09_regexp.html#c_yvsDvKWBej"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"one two 100"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/\d+/</span>));
<span class="cm-comment">// → ["100"]</span></pre>
<p><a class="p_ident" id="p_fFGmBROT0i" href="./09_regexp.html#p_fFGmBROT0i"></a>Когато регулярният израз съдържа групи под-изрази групирани в скоби, текстът, който съответства на тези групи също ще се появи в масива. Цялото съвпадение винаги е първият елемент. Следващият елемент е част от първата група (тази, чиято отварящата скоба е на първо място в израза), след това втората група и т.н.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HNCJk6hb0+" href="./09_regexp.html#c_HNCJk6hb0+"></a><span class="cm-keyword">var</span> <span class="cm-variable">quotedText</span> <span class="cm-operator">=</span> <span class="cm-string-2">/'([^']*)'/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">quotedText</span>.<span class="cm-property">exec</span>(<span class="cm-string">"she said 'hello'"</span>));
<span class="cm-comment">// → ["'hello'", "hello"]</span></pre>
<p><a class="p_ident" id="p_f4bciMASJ1" href="./09_regexp.html#p_f4bciMASJ1"></a>Когато една група свърши без съвпадение (например, когато е последвана от въпросителен знак), позицията и в изходящия масив ще съдържа <code>undefined</code>. По същия начин, когато една група е съчетана няколко пъти, само последното съвпадение ще се отзове в масива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_z3tMpYKOai" href="./09_regexp.html#c_z3tMpYKOai"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/bad(ly)?/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"bad"</span>));
<span class="cm-comment">// → ["bad", undefined]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/(\d)+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">"123"</span>));
<span class="cm-comment">// → ["123", "3"]</span></pre>
<p><a class="p_ident" id="p_zGhL5UaDaO" href="./09_regexp.html#p_zGhL5UaDaO"></a>Групите могат да бъдат полезни за извличане на части от <em>string</em>. Ако искаме не само да проверим дали <em>string</em> съдържа дата, но я извлечем и конструираме обект, който да я представя, можем да увием в скоби модела на цифрите и направо да вземем датата от резултата на <code>exec</code>.</p>
<p><a class="p_ident" id="p_B9SEqDbr+Y" href="./09_regexp.html#p_B9SEqDbr+Y"></a>Но първо, малко отклонение, в което ще обсъдим предпочитан начин за съхранение на дата и час стойности в JavaScript.</p>
<h2><a class="h_ident" id="h_+jaxcLjxpL" href="./09_regexp.html#h_+jaxcLjxpL"></a>Типът  Дата</h2>
<p><a class="p_ident" id="p_2NeTRvucQq" href="./09_regexp.html#p_2NeTRvucQq"></a>JavaScript има стандартен тип обект за представяне на дати или по-скоро, точки във времето. Той се нарича <code>Date</code>. Ако просто създадете обект дата чрез <code>new</code>, ще получите текущата дата и час.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GCz2vhG9tO" href="./09_regexp.html#c_GCz2vhG9tO"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>());
<span class="cm-comment">// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)</span></pre>
<p><a class="p_ident" id="p_IcV7kv3B1y" href="./09_regexp.html#p_IcV7kv3B1y"></a>Можете също така да създадете обект за определен период от време.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_SlUeqLFk0N" href="./09_regexp.html#c_SlUeqLFk0N"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>));
<span class="cm-comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>, <span class="cm-number">12</span>, <span class="cm-number">59</span>, <span class="cm-number">59</span>, <span class="cm-number">999</span>));
<span class="cm-comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>
<p><a class="p_ident" id="p_3P1Nh5Y+3T" href="./09_regexp.html#p_3P1Nh5Y+3T"></a>JavaScript използва конвенция, където номера на месеца започва от нула (така, че м.декември е 11), но номерата на дните започват от едно. Това е объркващо и глупаво. Бъдете внимателни.</p>
<p><a class="p_ident" id="p_gVdQSb0Lv9" href="./09_regexp.html#p_gVdQSb0Lv9"></a>Последните четири аргумента( часове, минути, секунди и милисекунди) не са задължителни и се отчитат като нулеви, когато не се зададат.</p>
<p><a class="p_ident" id="p_1mIMU5T5MA" href="./09_regexp.html#p_1mIMU5T5MA"></a>Времеви отрязъци се съхраняват, като брой от милисекунди от началото на 1970г., и с помощта на отрицателни числа за времето преди 1970г.(след конвенция определена от “Unix time”, която е изработена по това време). Метода <code>getTime</code> на обекта дата връща този номер. Той е голям, както можете да си представите.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_eWYgxNiBDF" href="./09_regexp.html#c_eWYgxNiBDF"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2013</span>, <span class="cm-number">11</span>, <span class="cm-number">19</span>).<span class="cm-property">getTime</span>());
<span class="cm-comment">// → 1387407600000</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">1387407600000</span>));
<span class="cm-comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>
<p><a class="p_ident" id="p_bU5mnU7KSw" href="./09_regexp.html#p_bU5mnU7KSw"></a>Ако дадете на <code>Date</code>конструктора един единствен аргумент, той ще бъде третиран , като такъв брой милисекунди. Можете да получите текущия брой милисекунди, чрез създаване на нов <code>Date</code> обект и извикате <code>getTime</code> върху него, но също и чрез извикване на <code>Date.now</code> функцията.</p>
<p><a class="p_ident" id="p_OMuHPQoSyh" href="./09_regexp.html#p_OMuHPQoSyh"></a>Дата обекта предоставя методи, като <code>getFullYear</code>, <code>getMonth</code>, <code>getDate</code>, <code>getHours</code>, <code>getMinutes</code> и <code>getSeconds</code> за извличане на техните компоненти. Има също така и <code>getYear</code>, който ви дава безполезна двуцифрена годишна стойност (като <code>93</code> или <code>14</code>).</p>
<p><a class="p_ident" id="p_/RCtQyD3w/" href="./09_regexp.html#p_/RCtQyD3w/"></a>Поставянето на скоби около частите на израза, показва че се интересуваме от това и сега може лесно да се създаде дата само със string.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_bHOf+E4R9h" href="./09_regexp.html#c_bHOf+E4R9h"></a><span class="cm-keyword">function</span> <span class="cm-variable">findDate</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">dateTime</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">string</span>);
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">3</span>]),
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]) <span class="cm-operator">-</span> <span class="cm-number">1</span>,
                  <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findDate</span>(<span class="cm-string">"30-1-2003"</span>));
<span class="cm-comment">// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></pre>
<h2><a class="h_ident" id="h_26ixny78VY" href="./09_regexp.html#h_26ixny78VY"></a>Думи и string граници</h2>
<p><a class="p_ident" id="p_xmknsh+RBC" href="./09_regexp.html#p_xmknsh+RBC"></a>За съжаление, <code>findDate</code> също успешно ще извлече безсмислена дата 00-1-3000 от <code>string “100-1-30000”</code>. Съвпадението може да се случи навсякъде в <em>string</em>, така че в този случай просто ще започне с втория характер и ще завърши в последния втори характер.</p>
<p><a class="p_ident" id="p_tKA0/BuA/v" href="./09_regexp.html#p_tKA0/BuA/v"></a>Ако искаме да наредим, че съвпадението трябва да обхване целия <em>string</em>, можем да добавим маркерите <code>^</code> и <code>$</code>. Ксор съвпада с началото на входния <em>string</em>, а харктера за долар съвпада с края. Така че, <code>/^\d+$/</code> съвпада със <em>string</em>, състоящ се изцяло от една или повече цифри, <code>/^!/</code> съвпада с всеки <em>string</em>, който започва с удивителен знак и <code>/x^/</code> не съвпада с всеки <em>string</em> (не може да има <em>x</em> преди началото на <em>string</em>-а).</p>
<p><a class="p_ident" id="p_dWIgppHuON" href="./09_regexp.html#p_dWIgppHuON"></a>Ако, от друга страна, просто искаме да се уверим, че започва с начална и завършва с дума граница, можем да използваме маркер <code>\b</code>. Граничната дума може да бъде в началото, в края или всяка точка на <em>string</em>, който има дума характер в него, (като в <code>\w</code>) за едната страна и <em>nonword</em> характер за другата.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_78q/iu+Tt7" href="./09_regexp.html#c_78q/iu+Tt7"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/cat/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\bcat\b/</span>.<span class="cm-property">test</span>(<span class="cm-string">"concatenate"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_btxd6luedx" href="./09_regexp.html#p_btxd6luedx"></a>Имайте в предвид, че маркера за граница, не представлява действителен характер. Той просто се прилага на регулярния израз за съвпадне само, когато дадено условие държи мястото, където той се появява в модела. </p>
<h2><a class="h_ident" id="h_In3b+t6uOO" href="./09_regexp.html#h_In3b+t6uOO"></a>Избор на модели</h2>
<p><a class="p_ident" id="p_G5RTt0AFku" href="./09_regexp.html#p_G5RTt0AFku"></a>Да кажем, че искаме да знаем дали част от текст съдържа не само номера, а номера последвани от думи, като прасе, крава или пиле, или някоя от техните форми за множествено число.</p>
<p><a class="p_ident" id="p_GcEbQJT+nS" href="./09_regexp.html#p_GcEbQJT+nS"></a>Бихме могли да напишем три регулярни израза и да ги тестваме по ред, но има и по-добър начин. Характера <code>(|)</code>, означава избор между лявата и дясната страна на модела. Така, че можем да направим това: </p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_T1BADhqiD4" href="./09_regexp.html#c_T1BADhqiD4"></a><span class="cm-keyword">var</span> <span class="cm-variable">animalCount</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+ (pig|cow|chicken)s?\b/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigs"</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">"15 pigchickens"</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_+vG2bBcznO" href="./09_regexp.html#p_+vG2bBcznO"></a>Скобите могат да бъдат използвани, за да се ограничи част от модела, когато операторът (|) се отнася до него и също може да сложите няколко такива оператора един до друг, за да направят своя избор между повече от два модела.</p>
<h2><a class="h_ident" id="h_AzxCBCKdvY" href="./09_regexp.html#h_AzxCBCKdvY"></a>Механизми  за  съвпадение</h2>
<p><a class="p_ident" id="p_fSpOFXMKY0" href="./09_regexp.html#p_fSpOFXMKY0"></a>Регулярните изрази могат да бъдат замислени, като технологични схеми. Това е схемата за изразяване на животновъдството в предишния пример:</p>
<div class="image">
  <img src="./media/re_pigchickens.svg" alt="Visualization of /\b\d+ (pig|cow|chicken)s?\b/">
</div>
<p><a class="p_ident" id="p_SNiUdMyezk" href="./09_regexp.html#p_SNiUdMyezk"></a>Нашият израз съвпада със <em>string</em>, ако можем да намерим пътя от лявата страна на диаграмата към дясната страна. Ние държим текущата позиция в <em>string</em> и всеки път, когато се движим през кутия, проверяваме за тази част от <em>string</em>, след като сегашната ни позиция съвпада с тази кутия.</p>
<p><a class="p_ident" id="p_MB99a8uIlE" href="./09_regexp.html#p_MB99a8uIlE"></a>Така че, ако се опитаме да сравним <code>"the 3 pigs"</code> с нашия регулярен израз, нашият напредък през диаграмата ще изглежда така:</p>
<div class="ulist"><ul>
<li>
<p><a class="p_ident" id="p_uBRT2kCvr2" href="./09_regexp.html#p_uBRT2kCvr2"></a>
  В 4-та позиция има дума граница, така че можем да преминем през  първата кутия.
</p>
</li>
<li>
<p><a class="p_ident" id="p_nO+Bi7hXkR" href="./09_regexp.html#p_nO+Bi7hXkR"></a>
  Все пак в позиция 4 ние откриваме цифра, така че можем да преминем през втората кутия.
</p>
</li>
<li>
<p><a class="p_ident" id="p_fQdWHxKgCF" href="./09_regexp.html#p_fQdWHxKgCF"></a>
  В 5-та позиция, единия път се връща обратно преди втората кутия (цифра), докато другия се движи напред през полето, което държи един интервал характер (празно пространство). Това пространство не е цифра, така че поемаме по втория път.
</p>
</li>
<li>
<p><a class="p_ident" id="p_KItk5iNp9m" href="./09_regexp.html#p_KItk5iNp9m"></a>
  Сега сме в позиция 6 (началото на “pigs”) и тройно разклонение в диаграмата. Тука ние не виждаме  “крава” или “пиле”, но виждаме “прасе”, така че поемаме по това разклонение.
</p>
</li>
<li>
<p><a class="p_ident" id="p_SowlGZC6lM" href="./09_regexp.html#p_SowlGZC6lM"></a>
  В позиция 9, след тройното разклонение, единият път прескача кутията за множествено число <em>s</em> и отива направо към крайната дума граница, докато другия път съвпада с <em>s</em>. Там е характера за множествено число <em>s</em>, а не дума граница, така че минаваме през кутия <em>s</em>.
</p>
</li>
<li>
<p><a class="p_ident" id="p_jtkHSJd1Eg" href="./09_regexp.html#p_jtkHSJd1Eg"></a>
  Вече сме в 10-та позиция(края на <em>string</em>) и можем да сравним само думата граница. Края на <em>string</em> се брои, като дума граница, така че минаваме през последната кутия и успешно съвпадаме този <em>string</em>.
</p>
</li>
</ul></div>
<p><a class="p_ident" id="p_dfwI9Viw95" href="./09_regexp.html#p_dfwI9Viw95"></a>Концептуално, двигателя на регулярния израз търси съвпадение в <em>string</em> по следния начин: той започва в началото на <em>string</em> и търси съвпадение там. В този случай там има дума граница, така че ще премине през първата кутия - но няма никаква цифра, така че ще се провали във втората кутия. После се премества на втория характер в <em>string</em> и се опита да започне ново съвпадение там .... и т.н., докато не открие съвпадение или не достигне края на <em>string</em> и реши, че наистина няма съвпадение.</p>
<h2 id="backtracking"><a class="h_ident" id="h_NFMtGK0tD3" href="./09_regexp.html#h_NFMtGK0tD3"></a>Връщане  на  зад</h2>
<p><a class="p_ident" id="p_tCd15MFAty" href="./09_regexp.html#p_tCd15MFAty"></a>Регулярния израз <code>/\b([01]+b|\d+|[\da-f]+h)\b/</code> търси съвпадение за бинарно число последвано от <em>b</em>, обикновено десетично число без никакъв суфикс характер или шестнадестетично число (т.е. основа 16 с буквите от <em>a</em> до <em>f</em>, постоянно за цифри от 10 до 15) следвано от <em>h</em>. Това е съответната схема:</p>
<div class="image">
  <img src="./media/re_number.svg" alt="Visualization of /\b([01]+b|\d+|[\da-f]+h)\b/">
</div>
<p><a class="p_ident" id="p_CkxEfo2iHH" href="./09_regexp.html#p_CkxEfo2iHH"></a>При съвпадение на този израз, често се случва горното бинарно (binary) разклонение да е въведено  въпреки, че входът всъщност не съдържа бинарно число. Когато съвпадне със <code>string “103”</code>, например, става ясно, че само в 3 сме в грешния клон. Тоест <em>string</em> съвпада с израза, само клона в който сме в момента не.</p>
<p><a class="p_ident" id="p_SjTCKE9hvf" href="./09_regexp.html#p_SjTCKE9hvf"></a>Това съответствие е <em>backtracks</em> (връщане на зад). При влизане в клон, то си спомня текущата позиция (в този случай началото на string, само през първото поле на границата в схемата) така че, да може да се върне и да пробва друг клон, ако сегашния не работи. За <code>string "103"</code> след, като се натъкне на 3, то пробва на клона за десетични числа. Той съвпада, така че, даденото съвпадение се съобщава в края на краищата.</p>
<p><a class="p_ident" id="p_+Hy4DF1l6V" href="./09_regexp.html#p_+Hy4DF1l6V"></a>Съпоставянето спира веднага след, като установи пълно съвпадение. Това означава, че много клонове потенциално биха могли да съответстват на <em>string</em>, но се използва само първия (от подредбата, по която клоните се появяват в регулярния израз). </p>
<p><a class="p_ident" id="p_zEBIV8lYeb" href="./09_regexp.html#p_zEBIV8lYeb"></a>Връщането на зад също се случва с оператори за повторение, като + и <code>*</code>. Ако съвпадне <code>/^.*x/</code> със <code>"abcxe"</code>, часта <code>.*</code> ще се опита първо да консумира целия <em>string</em>. След което, двигателя ще осъзнае, че се нуждае от <code>х</code>, за да съвпадне с модела. Тъй като няма <code>х</code> на края на <em>string</em>, операторът  *  се опитва да съответства на един характер по-малко. Но съгласувателя пак не намира <code>х</code> след <code>abcx</code>, така че се връща на зад отново, за съвпадение на оператора звезда само с <code>abc</code>. Сега намира <code>х</code>, от който има нужда и отчита успешно съвпадение с позиции от 0 до 4.</p>
<p><a class="p_ident" id="p_VxCrsg7UEp" href="./09_regexp.html#p_VxCrsg7UEp"></a>Възможно е да се напишат регулярни изрази, които да направят много връщания на зад. Този проблем възниква, когато един модел може да се сравнява с парче от въвеждането по много различни начини. Например, ако се объркате докато пишете бинарен номер за регулярен израз, вие можете да напишете нещо такова: <code>/([01]+)+b/</code>.</p>
<div class="image">
  <img src="./media/re_slow.svg" alt="Visualization of /([01]+)+b/">
</div>
<p><a class="p_ident" id="p_5cI0Ma3Wy8" href="./09_regexp.html#p_5cI0Ma3Wy8"></a>Ако това се опита да съответства на някаква дълга поредица от нули и единици, без да следи <em>b</em> характера, съгласувателя първо ще премине през вътрешната линия, докато не прочете всички цифри. След това забелязва, че няма <em>b</em>, така че се връща една позиция на зад и минава през външната линия веднъж, излиза отново, опитвайки се с връщане на зад да излезе от вътрешната линия още веднъж. Той ще продължи да опитва всеки възможен маршрут през тези две вериги. Това означава, че обема на работа се удвоява с всеки допълнителен характер. Дори само на дузина характери, резултата за съвпадението ще отнеме много време - практически завинаги.</p>
<h2><a class="h_ident" id="h_k0YuTOu54D" href="./09_regexp.html#h_k0YuTOu54D"></a>Метод  replace</h2>
<p><a class="p_ident" id="p_HMQv5qrs78" href="./09_regexp.html#p_HMQv5qrs78"></a><em>String</em> стойностите имат метод <code>replace</code>, който се използва за замяна на част от <em>string</em> с друг <em>string</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_k4SqDNUcsT" href="./09_regexp.html#c_k4SqDNUcsT"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"papa"</span>.<span class="cm-property">replace</span>(<span class="cm-string">"p"</span>, <span class="cm-string">"m"</span>));
<span class="cm-comment">// → mapa</span></pre>
<p><a class="p_ident" id="p_jjBKX9l81o" href="./09_regexp.html#p_jjBKX9l81o"></a>Първият аргумент може да бъде регулярен израз, като в този случай първото съвпадение на регулярния израз се заменя. Когато опцията <code>g</code> (за глобално) е добавена към регулярния израз, всички съвпадения в <em>string</em> ще бъдат заменени, а не само първото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_L+rdP1BZ/D" href="./09_regexp.html#c_L+rdP1BZ/D"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barobudur</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Borobudur"</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/g</span>, <span class="cm-string">"a"</span>));
<span class="cm-comment">// → Barabadar</span></pre>
<p><a class="p_ident" id="p_k90SO6OTUP" href="./09_regexp.html#p_k90SO6OTUP"></a>Би било разумно, ако изборът между заменяне на едно съвпадение или всички съвпадения, беше направен чрез допълнителен аргумент на <code>replace</code> или чрез предоставяне на различен метод <code>replaceAll</code>. Но за съжаление, по някаква причина изборът се основава на свойство на регулярния израз.</p>
<p><a class="p_ident" id="p_/5YU/Qo2Np" href="./09_regexp.html#p_/5YU/Qo2Np"></a>Истинската сила на използване на регулярни изрази с <code>replace</code> идва от факта, че можем да се върнем към съвпадащи групи в заменения <em>string</em>. Например, да кажем, имаме голям <em>string</em> съдържащ имена на хора, по едно име на ред във формат <code>Lastname, Firstname</code>. Ако искаме да сменим тези имена и да премахнем запетаята, за да получим друг формат  <code>Firstname Lastname</code>, можем да използваме следния код:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rkgG8o9tWE" href="./09_regexp.html#c_rkgG8o9tWE"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(
  <span class="cm-string">"Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"</span>
    .<span class="cm-property">replace</span>(<span class="cm-string-2">/([\w ]+), ([\w ]+)/g</span>, <span class="cm-string">"$2 $1"</span>));
<span class="cm-comment">// → Grace Hopper</span>
<span class="cm-comment">//   John McCarthy</span>
<span class="cm-comment">//   Dennis Ritchie</span></pre>
<p><a class="p_ident" id="p_yMNsWvr4Lh" href="./09_regexp.html#p_yMNsWvr4Lh"></a> <code>$1</code> и <code>$2</code> в заместващия <em>string</em> се отнасят за групите в скобите в модела. <code>$1</code> се заменя с текста, който съвпада с първата група, <code>$2</code> с втората и т. н. до <code>$9</code>. Цялото съвпадение може да бъде посочено с <code>$&amp;</code>.</p>
<p><a class="p_ident" id="p_vI+NtinnDZ" href="./09_regexp.html#p_vI+NtinnDZ"></a>Също така може да се подаде функция вместо <em>string</em>, като втори аргумент към <code>replace</code>. За всяка замяна, функцията се извиква със съвпадащи групи (или цялото съвпадение), като аргумент и нейната върната стойност ще бъде вмъкната в новия <em>string</em>.</p>
<p><a class="p_ident" id="p_3oXsRdfp6a" href="./09_regexp.html#p_3oXsRdfp6a"></a>Ето един прост пример: </p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Br7Xx39ol0" href="./09_regexp.html#c_Br7Xx39ol0"></a><span class="cm-keyword">var</span> <span class="cm-variable">s</span> <span class="cm-operator">=</span> <span class="cm-string">"the cia and fbi"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">s</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\b(fbi|cia)\b/g</span>, <span class="cm-keyword">function</span>(<span class="cm-def">str</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">str</span>.<span class="cm-property">toUpperCase</span>();
}));
<span class="cm-comment">// → the CIA and FBI</span></pre>
<p><a class="p_ident" id="p_EbMXoAagyr" href="./09_regexp.html#p_EbMXoAagyr"></a>А тука още по-интересно:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yP56zRm97Q" href="./09_regexp.html#c_yP56zRm97Q"></a><span class="cm-keyword">var</span> <span class="cm-variable">stock</span> <span class="cm-operator">=</span> <span class="cm-string">"1 lemon, 2 cabbages, and 101 eggs"</span>;
<span class="cm-keyword">function</span> <span class="cm-variable">minusOne</span>(<span class="cm-def">match</span>, <span class="cm-def">amount</span>, <span class="cm-def">unit</span>) {
  <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">amount</span>) <span class="cm-operator">-</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) <span class="cm-comment">// only one left, remove the 's'</span>
    <span class="cm-variable-2">unit</span> <span class="cm-operator">=</span> <span class="cm-variable-2">unit</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">unit</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-string">"no"</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">+</span> <span class="cm-string">" "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">unit</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stock</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/(\d+) (\w+)/g</span>, <span class="cm-variable">minusOne</span>));
<span class="cm-comment">// → no lemon, 1 cabbage, and 100 eggs</span></pre>
<p><a class="p_ident" id="p_bv4e/DVilz" href="./09_regexp.html#p_bv4e/DVilz"></a>Това взема <em>string</em>, намира всички появявания на номер, следван от буквено-цифрова дума и връща <em>string</em>, където за всеки такъв случай се отнема по едно.</p>
<p><a class="p_ident" id="p_pEPUrWK5UJ" href="./09_regexp.html#p_pEPUrWK5UJ"></a>Групата <code>(\d+)</code> завършва, като аргумент <code>amount</code> към функцията, а групата <code>(\w+)</code> получава обвързване към <code>unit</code>. Функцията преобразува <code>amount</code> към номер, което винаги работи, тъй като съвпада с <code>\d+</code> и прави някои корекции в случай, че има само едно или нула от ляво.</p>
<h2><a class="h_ident" id="h_kiECehz+i+" href="./09_regexp.html#h_kiECehz+i+"></a>Ненаситност</h2>
<p><a class="p_ident" id="p_Q5tdrWs0Tm" href="./09_regexp.html#p_Q5tdrWs0Tm"></a>Не е трудно, когато се използва <code>replace</code> да се напише функция, която премахва  всички коментари в парче JavaScript код. Това е първи опит:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_zdj+sx4mis" href="./09_regexp.html#c_zdj+sx4mis"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 + /* 2 */3"</span>));
<span class="cm-comment">// → 1 + 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"x = 10;// ten!"</span>));
<span class="cm-comment">// → x = 10;</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1  1</span></pre>
<p><a class="p_ident" id="p_6+ZTC2M5ci" href="./09_regexp.html#p_6+ZTC2M5ci"></a>Частта преди оператора или (|) просто съвпада с две наклонени черти, последвана от произволен брой характери за нов ред. Частта за многоредови коментари е по-ангажираща. Ние използваме <code>[^]</code> (за всеки характер, който не е в празен набор от характери), като начин да съответства на всеки характер. Не можем просто да използваме точка  тук, защото блоковите коментари могат да продължат на нов ред, а точките не съвпадат с характера за нов ред.</p>
<p><a class="p_ident" id="p_s9E9JYjAYp" href="./09_regexp.html#p_s9E9JYjAYp"></a>Но изходът на последния пример изглежда е грешен. Защо?</p>
<p><a class="p_ident" id="p_atS1ERkauC" href="./09_regexp.html#p_atS1ERkauC"></a>Частта от израза <code>[^]*</code>, както описах в раздела за връщане на зад, ще е първото съвпадение, толкова колкото може. Ако това е причината следващата част на модела да се провали, съгласувателя се връща на зад един характер и се опитва отново там. В примера, съгласувателя се опитва да съответства на цялата останала част от <em>string</em>-а и след това се връща обратно от там. Той ще намери поява на <code>*/</code> след връщане на зад с четири характера и съвпада с него. Това не е онова, което искахме - намерението беше да съответства на един единствен коментар, за да не вървим по целия път до края на кода и да намерим края на последния блок коментари.</p>
<p><a class="p_ident" id="p_eNtLSVH65f" href="./09_regexp.html#p_eNtLSVH65f"></a>Заради това поведение, ние казваме, че операторите за повторение (<code>+</code>, <code>*</code>,
<code>?</code>, и <code>{}</code>) са <em>greedy</em> (ненаситни), това означава, че те съвпадат толкова колкото могат и се връщат от там. Ако сложим въпросителен знак след тях (<code>+?</code>, <code>*?</code>, <code>??</code>, <code>{}?</code>), те стават <em>nongreed</em> (не-лакоми) и започват да съответстват на най-малко съвпадения, само когато оставащия модел не се побира в по-малко съвпадение.</p>
<p><a class="p_ident" id="p_0L47KZXZKa" href="./09_regexp.html#p_0L47KZXZKa"></a>И това е точно онова, което искаме в този случай. Докато звездата * съответства на най-малкия участък от характери, което ни води до <code>*/</code>, ние консумираме един блок с коментари и нищо повече.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_0e+jWcCHlB" href="./09_regexp.html#c_0e+jWcCHlB"></a><span class="cm-keyword">function</span> <span class="cm-variable">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="cm-string">""</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">"1 /* a */+/* b */ 1"</span>));
<span class="cm-comment">// → 1 + 1</span></pre>
<p><a class="p_ident" id="p_DQjgIV+cP6" href="./09_regexp.html#p_DQjgIV+cP6"></a>Много грешки в регулярните изрази могат да бъдат проследени до неволно използване на ненаситни оператори, където <em>nongreed</em> ще работят една идея по-добре. Когато използвате оператор за повторение, помислете първо за <em>nongreed</em> вариант.</p>
<h2><a class="h_ident" id="h_Rhu25fogrG" href="./09_regexp.html#h_Rhu25fogrG"></a>Динамично  създаване  на  RegExp  обекти</h2>
<p><a class="p_ident" id="p_2A78iOXDCO" href="./09_regexp.html#p_2A78iOXDCO"></a>Има случаи, в които може да не знаете точният модел, който трябва да съответства насреща, когато пишете кода си. Да речем, че търсите името на потребител в част от текст и му прилагате долна черта за да се откроява. Тъй като, вие ще разберете името само след, като програмата действително работи, не може да използвате наклонена черта базирана на нотация.</p>
<p><a class="p_ident" id="p_fuOCNTjCbk" href="./09_regexp.html#p_fuOCNTjCbk"></a>Но можете да изградите един <em>string</em> и да използвате <code>RegExp</code> конструктора върху него. Ето един пример:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Ev1eKzYhvk" href="./09_regexp.html#c_Ev1eKzYhvk"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"harry"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"Harry is a suspicious character."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">name</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → _Harry_ is a suspicious character.</span></pre>
<p><a class="p_ident" id="p_J6H1NBoQy/" href="./09_regexp.html#p_J6H1NBoQy/"></a>Когато създаваме маркери за граница <code>\b</code>, ние трябва да използваме две обратно наклонени черти, защото ги пишем в нормален <em>string</em>, нормално наклонената черта, затваря регулярния израз. Вторият аргумент на <code>RegExp</code> конструктора съдържа вариантите за регулярния израз - в този случай <code>"gi"</code> за глобално и да се влияе от случая.</p>
<p><a class="p_ident" id="p_W/atxcKoEp" href="./09_regexp.html#p_W/atxcKoEp"></a>Но какво правим, ако името е <code>"dea+hl[]rd"</code>, защото нашият потребител е изперкал тинейджър? Това ще доведе до безсмислен регулярен израз, който всъщност няма да съвпада с името на потребителя.</p>
<p><a class="p_ident" id="p_0Mx4Lf/w4/" href="./09_regexp.html#p_0Mx4Lf/w4/"></a>За да заобиколим този проблем, можем да добавим обратно наклонени черти пред всеки характер, в който се съмняваме. Добавянето на обратни наклонени черти, пред буквени характери е лоша идея, защото такива неща, като <code>\b</code> и <code>\n</code> имат специално значение. Но <code>escaping</code> на всичко, което не е буквено-цифрово или празно пространство е безопасно.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_6gobfQUYsI" href="./09_regexp.html#c_6gobfQUYsI"></a><span class="cm-keyword">var</span> <span class="cm-variable">name</span> <span class="cm-operator">=</span> <span class="cm-string">"dea+hl[]rd"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"This dea+hl[]rd guy is super annoying."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">escaped</span> <span class="cm-operator">=</span> <span class="cm-variable">name</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[^\w\s]/g</span>, <span class="cm-string">"\\$&amp;"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">"\\b("</span> <span class="cm-operator">+</span> <span class="cm-variable">escaped</span> <span class="cm-operator">+</span> <span class="cm-string">")\\b"</span>, <span class="cm-string">"gi"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">"_$1_"</span>));
<span class="cm-comment">// → This _dea+hl[]rd_ guy is super annoying.</span></pre>
<h2><a class="h_ident" id="h_Txg7z4j/ei" href="./09_regexp.html#h_Txg7z4j/ei"></a>Метод  за  търсене</h2>
<p><a class="p_ident" id="p_7vPpkhqhrD" href="./09_regexp.html#p_7vPpkhqhrD"></a>Метода <code>indexOf</code> за <em>strings</em> не може да се извика с регулярен израз. Но има друг метод <code>search</code>, който очаква регулярен израз. Както <code>indexOf</code>, той връща първия индекс, на който е намерен израза или -1, когато не е намерен.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_YWkmdsq1UJ" href="./09_regexp.html#c_YWkmdsq1UJ"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"  word"</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"    "</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → -1</span></pre>
<p><a class="p_ident" id="p_tqlyvUKoi5" href="./09_regexp.html#p_tqlyvUKoi5"></a>За съжаление, няма начин да се посочи, от къде трябва да започне съвпадението (както можем да направим с втория аргумент на <code>indexOf</code>), което често е полезно.</p>
<h2><a class="h_ident" id="h_duFTd2hqd0" href="./09_regexp.html#h_duFTd2hqd0"></a>Свойството  lastIndex</h2>
<p><a class="p_ident" id="p_heIQ0/XXEu" href="./09_regexp.html#p_heIQ0/XXEu"></a>Метода <code>exec</code> също не предоставя удобен начин за започване на търсенето от дадена позиция в <em>string</em>. Но предоставя неудобен начин.</p>
<p><a class="p_ident" id="p_F+JgzwxLtK" href="./09_regexp.html#p_F+JgzwxLtK"></a>Обекта на регулярните изрази има свойства. Едно такова свойство е <code>source</code>, който съдържа <em>string</em> създаден от израза. Друго свойство е <code>lastIndex</code>, който контролира в някои ограничени случаи, къде да започне следващото съвпадение.</p>
<p><a class="p_ident" id="p_y8GS9OJXkh" href="./09_regexp.html#p_y8GS9OJXkh"></a>При тези обстоятелства, регулярния израз трябва да има глобална (<code>g</code>) поддръжка и съвпадението трябва да се случи чрез метода <code>exec</code>. Отново по-разумно решение би било, да се разреши допълнителен аргумент, който да бъде приет от <code>exec</code>, но здравият разум не е определяща характеристика за интерфейса на регулярните изрази в JavaScript.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Wy75i+pob7" href="./09_regexp.html#c_Wy75i+pob7"></a><span class="cm-keyword">var</span> <span class="cm-variable">pattern</span> <span class="cm-operator">=</span> <span class="cm-string-2">/y/g</span>;
<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">pattern</span>.<span class="cm-property">exec</span>(<span class="cm-string">"xyzzy"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span>);
<span class="cm-comment">// → 5</span></pre>
<p><a class="p_ident" id="p_hjLQ+57mDd" href="./09_regexp.html#p_hjLQ+57mDd"></a>Ако съвпадението е било успешно, извикването на <code>exec</code> автоматично актуализира свойството <code>lastIndex</code>, до точката след съвпадението. Ако не е открито съвпадение, <code>lastIndex</code> се настройва обратно към нула, което също така е стойността, която има в обекта на новопостроения регулярния израз.</p>
<p><a class="p_ident" id="p_042bNmzNZK" href="./09_regexp.html#p_042bNmzNZK"></a>Когато използвате глобален регулярен израз, за няколко извиквания на <code>exec</code>, тези автоматични актуализации на свойството <code>lastIndex</code> може да предизвикат проблеми. Регулярният израз може случайно да започне от индекс, който е останал от предното извикване.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ko4+8FBNOB" href="./09_regexp.html#c_ko4+8FBNOB"></a><span class="cm-keyword">var</span> <span class="cm-variable">digit</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">"here it is: 1"</span>));
<span class="cm-comment">// → ["1"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">"and now: 1"</span>));
<span class="cm-comment">// → null</span></pre>
<p><a class="p_ident" id="p_9l7tQ3SsME" href="./09_regexp.html#p_9l7tQ3SsME"></a>Друг интересен ефект на глобалната опция е, че тя променя начина на работа на метода <code>match</code> в <em>string</em>. Когато се извика с глобален израз, вместо да връща масив подобен на този върнат от <code>exec</code>, <code>match</code> ще намери всички съвпадения на модела в <em>string</em>-а и ще върне масив, съдържащ съвпадащите <em>strings</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Omc+QSkcb/" href="./09_regexp.html#c_Omc+QSkcb/"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Banana"</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/an/g</span>));
<span class="cm-comment">// → ["an", "an"]</span></pre>
<p><a class="p_ident" id="p_zFHO63a2iV" href="./09_regexp.html#p_zFHO63a2iV"></a>Така че, бъдете внимателни с глобалните регулярни изрази. В случаите, когато те са необходими, извиквайте <code>replace</code> и в местата, където изрично искате, използвате <code>lastIndex</code> ( обикновено това са единствените случаи, където искате да ги използвате).</p>
<h3><a class="h_ident" id="h_m0fs21dHEg" href="./09_regexp.html#h_m0fs21dHEg"></a>Цикъл  за  съвпадения</h3>
<p><a class="p_ident" id="p_sFhvrUR1vm" href="./09_regexp.html#p_sFhvrUR1vm"></a>Един общ модел е да се сканират всички съвпадения на модел в string, по начин, който ни дава достъп до обекта на съвпадението в тялото на цикъл с помощта на <code>lastIndex</code> и <code>exec</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_VfL6IpLSid" href="./09_regexp.html#c_VfL6IpLSid"></a><span class="cm-keyword">var</span> <span class="cm-variable">input</span> <span class="cm-operator">=</span> <span class="cm-string">"A string with 3 numbers in it... 42 and 88."</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b(\d+)\b/g</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">match</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">number</span>.<span class="cm-property">exec</span>(<span class="cm-variable">input</span>))
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Found"</span>, <span class="cm-variable">match</span>[<span class="cm-number">1</span>], <span class="cm-string">"at"</span>, <span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → Found 3 at 14</span>
<span class="cm-comment">//   Found 42 at 33</span>
<span class="cm-comment">//   Found 88 at 40</span></pre>
<p><a class="p_ident" id="p_ZdCI2+edqA" href="./09_regexp.html#p_ZdCI2+edqA"></a>Това се прави с използването на факта, че стойността на израза за присвояване (<code>=</code>) е присвоената стойност. Така, че с помоща на <code>match = number.exec(input)</code>, като условие в <code>while</code> цикъла, извършваме съвпадението в началото на всяка итерация, съхраняваме резултата в променлива и спираме цикъла, когато няма намерени повече съвпадения.</p>
<h2 id="ini"><a class="h_ident" id="h_RGsf6ah1EY" href="./09_regexp.html#h_RGsf6ah1EY"></a>Разбор  на  INI  файла</h2>
<p><a class="p_ident" id="p_JbrLORqV9r" href="./09_regexp.html#p_JbrLORqV9r"></a>В заключение на главата, ще разгледаме един проблем, който се отнася до регулярните изрази. Представете си, че пишем програма за автоматично събиране на информация за нашите враговете от Интернет. (Ние всъщност няма да напишем тази програма тук, и по-точно, частта, която чете конфигурационния файл. Съжалявам за пропуска.) Конфигурационния файл, изглежда така:</p>
<pre data-language="text/plain" class="snippet cm-s-default"><a class="c_ident" id="c_OXIK3oNw6Q" href="./09_regexp.html#c_OXIK3oNw6Q"></a>searchengine=http://www.google.com/search?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; each section concerns an individual enemy
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[gargamel]
fullname=Gargamel
type=evil sorcerer
outputdir=/home/marijn/enemies/gargamel</pre>
<p><a class="p_ident" id="p_OgIQS1TJxB" href="./09_regexp.html#p_OgIQS1TJxB"></a>Точните правила за този формат (който, всъщност е широко използван формат, обикновено се нарича <em>INI</em> файл) са както следва:</p>
<div class="ulist"><ul>
<li>
<p><a class="p_ident" id="p_jIewfc/40B" href="./09_regexp.html#p_jIewfc/40B"></a>
Празни редове и редове, започващи с точка и запетая се игнорират.
</p>
</li>
<li>
<p><a class="p_ident" id="p_O/dGCr+aR5" href="./09_regexp.html#p_O/dGCr+aR5"></a>
Редове увити в <code>[</code> и <code>]</code> започват нова секция.
</p>
</li>
<li>
<p><a class="p_ident" id="p_l2Yjl1fUVB" href="./09_regexp.html#p_l2Yjl1fUVB"></a>
Редове, съдържащи буквено-цифров идентификатор последван от характера за <code>=</code>, добавят настройка към текущата секция.
</p>
</li>
<li>
<p><a class="p_ident" id="p_bCaQwCXJCi" href="./09_regexp.html#p_bCaQwCXJCi"></a>
Всичко друго е невалидно.
</p>
</li>
</ul></div>
<p><a class="p_ident" id="p_LWCnDNCUFW" href="./09_regexp.html#p_LWCnDNCUFW"></a>Нашата задача е да се преобразува <em>string</em>, като този в масив от обекти, всеки с <code>name</code> свойство и масив от настройки. Ще ни трябва един такъв обект за всяка секция и един за глобалните настройки в горната част.</p>
<p><a class="p_ident" id="p_8golZvaoZS" href="./09_regexp.html#p_8golZvaoZS"></a>Тъй като, формата трябва да бъде обработен ред по ред, разделянето на файла на отделни редове е добро начало. Ние използвахме <code>string.split("\n")</code> за да направим това в <a href="./06_object.html#split">Глава 6</a>. Някои операционни системи обаче, не използват само характера за нов ред при  разделяне на редове, а използват характера за връщане последван от този за нов ред (<code>"\r\n"</code>). Като се има в предвид, че метода <code>split</code> позволява също и регулярен израз, като негов аргумент, можем да разделим регулярния израз на <code>/\r?\n/</code>, което позволява едновременно използването на <code>"\n"</code> и <code>"\r\n"</code> между редовете.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_4pk9fouX3a" href="./09_regexp.html#c_4pk9fouX3a"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseINI</span>(<span class="cm-def">string</span>) {
  <span class="cm-comment">// Start with an object to hold the top-level fields</span>
  <span class="cm-keyword">var</span> <span class="cm-def">currentSection</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-atom">null</span>, <span class="cm-property">fields</span>: []};
  <span class="cm-keyword">var</span> <span class="cm-def">categories</span> <span class="cm-operator">=</span> [<span class="cm-variable-2">currentSection</span>];

  <span class="cm-variable-2">string</span>.<span class="cm-property">split</span>(<span class="cm-string-2">/\r?\n/</span>).<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">line</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">match</span>;
    <span class="cm-keyword">if</span> (<span class="cm-string-2">/^\s*(;.*)?$/</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">line</span>)) {
      <span class="cm-keyword">return</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^\[(.*)\]$/</span>)) {
      <span class="cm-variable-2">currentSection</span> <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>], <span class="cm-property">fields</span>: []};
      <span class="cm-variable-2">categories</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">currentSection</span>);
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^(\w+)=(.*)$/</span>)) {
      <span class="cm-variable-2">currentSection</span>.<span class="cm-property">fields</span>.<span class="cm-property">push</span>({<span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>],
                                  <span class="cm-property">value</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">2</span>]});
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Line '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">line</span> <span class="cm-operator">+</span> <span class="cm-string">"' is invalid."</span>);
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable-2">categories</span>;
}</pre>
<p><a class="p_ident" id="p_aXK65jiU6o" href="./09_regexp.html#p_aXK65jiU6o"></a>Този код минава през всеки ред във файла и актуализира  обекта на “текущата секция”, който върви заедно. Първо се проверява дали редът може да се игнорира, използвайки израза <code>/^\s*(;.*)?$/</code>. Виждате ли как работи? Частта между скобите ще съвпадне с коментарите, а въпросителния знак <code>?</code> ще се увери, че също съвпада с редове съдържащи само интервали.</p>
<p><a class="p_ident" id="p_CKB+LQEvXY" href="./09_regexp.html#p_CKB+LQEvXY"></a>Ако реда не е коментар, кода след това проверява дали  с този ред започва нова секция. Ако е така, той създава обект за нова текуща секция, към който ще бъдат добавени следващите настройки.</p>
<p><a class="p_ident" id="p_XjKuxzEtw/" href="./09_regexp.html#p_XjKuxzEtw/"></a>Последната смислена възможност е, че редът е нормален и кода го добавя към обекта на текущата секция.</p>
<p><a class="p_ident" id="p_oU+yccn9dn" href="./09_regexp.html#p_oU+yccn9dn"></a>Ако реда не съвпада с някоя от тези форми, функцията хвърля грешка.</p>
<p><a class="p_ident" id="p_FPzqsloIkT" href="./09_regexp.html#p_FPzqsloIkT"></a>Обърнете внимание на повтарящото се използване на <code>^</code> и <code>$</code>, което ни уверява, че изразът съвпада с цялия ред, а не само с част от него. Оставянето на тези извън резултата в кода, който общо взето работи, но се държи странно за някои входове, може да създаде трудности при проследяването на грешки.</p>
<p><a class="p_ident" id="p_SLY/jPojdT" href="./09_regexp.html#p_SLY/jPojdT"></a>Моделът <code>if (match
= string.match(...))</code> е подобен на трика за използване на присвояването, като условие за <code>while</code> цикъла. Ако не сте сигурни, че извикването на <code>match</code> ще успее, може да получите достъп до получения обект само вътре в <code>if</code> изявлени, за тестване на това. За да не се прекъсне веригата на <code>if</code> формите, ще присвоим резултата от съвпадението към променлива и веднага ще използваме това присвояване, като тест в <code>if</code> изявлението.</p>
<h2><a class="h_ident" id="h_+y54//b0l+" href="./09_regexp.html#h_+y54//b0l+"></a>Международни  характери</h2>
<p><a class="p_ident" id="p_Gw6mX6NBqt" href="./09_regexp.html#p_Gw6mX6NBqt"></a>Поради първоначално опростеното прилагане на JavaScript и на факта, че този опростен подход беше непоклатим, като стандартно поведение, регулярните изрази в JavaScript  са доста тъпи като характери, които не са включени в английския език. Например, що се отнася до регулярните изрази в JavaScript, “думата характер” е само един от 26-те характера в латинската азбука (главни и малки букви) и по някаква причина също и характера за долна черта. Неща като <em>é</em> или <em>β</em>, които най-категорично са думи характери, няма да съвпаднат с <code>\w</code>, а ще съответстват на главна <code>\W</code> на <em>nonword</em> категорията.</p>
<p><a class="p_ident" id="p_hQosIPfRoo" href="./09_regexp.html#p_hQosIPfRoo"></a>По странна историческа случайност <code>\s</code> за празно пространство (<em>whitespace</em>) няма такъв проблем и съвпада с всички знаци, които Unicode счита за празно пространство, включително и неща, като непрекъснато пространство и Монголската гласна за сепаратор.</p>
<p><a class="p_ident" id="p_ssmpiUydMx" href="./09_regexp.html#p_ssmpiUydMx"></a>Някои реализации на регулярни изрази в други програмни езици имат синтаксис, който да съответства на специфични категории характери в Unicode, например “всички главни букви”, ”всички препинателни знаци” или ”контролни характери”. Има планове за добавяне на поддръжка за такива категории в JavaScript, но за съжаление изглежда, че няма да се реализират в близко бъдеще.</p>
<h2 id="summary_regexp"><a class="h_ident" id="h_ErccPg/l98" href="./09_regexp.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_/hQX04GtpS" href="./09_regexp.html#p_/hQX04GtpS"></a>Регулярните изрази са обекти, които представляват модели в <em>strings</em>. Те използват собствения си синтаксис за да изразят тези модели.</p>
<table>
<tbody><tr>
<td><code>/abc/</code></td>
<td>Поредица от характери</td>
</tr>
<tr>
<td><code>/[abc]/</code></td>
<td>Всеки характер от набора с характери</td>
</tr>
<tr>
<td><code>/[^abc]/</code></td>
<td>Всеки характер, който не е в набора от характери</td>
</tr>
<tr>
<td><code>/[0-9]/</code></td>
<td>Всеки характер в диапазона от характери</td>
</tr>
<tr>
<td><code>/x+/</code></td>
<td>Едно или повече съответствия на модела <code>x</code></td>
</tr>
<tr>
<td><code>/x+?/</code></td>
<td>Едно или повече съответствия, <code>nongreedy</code></td>
</tr>
<tr>
<td><code>/x*/</code></td>
<td>Нула или повече съответствия</td>
</tr>
<tr>
<td><code>/x?/</code></td>
<td>Нула или едно съответствие</td>
</tr>
<tr>
<td><code>/x{2,4}/</code></td>
<td>Между две и четири съответствия</td>
</tr>
<tr>
<td><code>/(abc)/</code></td>
<td>Група</td>
</tr>
<tr>
<td><code>/a|b|c/</code></td>
<td>Всеки един от няколко модела</td>
</tr>
<tr>
<td><code>/\d/</code></td>
<td>Всяка цифра характер</td>
</tr>
<tr>
<td><code>/\w/</code></td>
<td>Един буквено-цифров характер (“дума характер”)</td>
</tr>
<tr>
<td><code>/\s/</code></td>
<td>Всеки интервал характер</td>
</tr>
<tr>
<td><code>/./</code></td>
<td>Всеки характер, с изключение на характера за нов ред</td>
</tr>
<tr>
<td><code>/\b/</code></td>
<td>Дума граница</td>
</tr>
<tr>
<td><code>/^/</code></td>
<td>Начало на вход</td>
</tr>
<tr>
<td><code>/$/</code></td>
<td>Край на вход</td>
</tr>
</tbody></table>
<p><a class="p_ident" id="p_AVY5pFcEyH" href="./09_regexp.html#p_AVY5pFcEyH"></a>Регулярният израз има метод <code>test</code> за тестване дали даден <em>string</em> съвпада с него. Той има също и <code>exec</code> метод, който когато установи съвпадение, връща масив съдържащ всички съвпадащи групи. Такъв масив има свойството <code>index</code>, което показва къде е започнало съвпадението.</p>
<p><a class="p_ident" id="p_Ml7hKXO6Ll" href="./09_regexp.html#p_Ml7hKXO6Ll"></a><em>Strings</em> имат <code>match</code> метод, за съпоставянето им с регулярн израз и <code>search</code> метод за търсене, връщайки само началната позиция в съвпадението. Техният <code>replace</code> метод, може да замени съвпаденията на един модел със заменящ <em>string</em>. Алтернативно, можете да подадете функция към <code>replace</code>, която да бъде използвана за изграждане на заместващ <em>string</em> на базата на текста за съвпадението и съвпадащите групи.</p>
<p><a class="p_ident" id="p_XsUkGFZG+B" href="./09_regexp.html#p_XsUkGFZG+B"></a>Регулярни изрази могат да имат опции, които са написани след наклонената черта за затваряне. Опцията <code>i</code> прави съвпадението да се влияе от случая, докато опцията <code>g</code> прави израза глобален, което наред с други неща прави метода <code>replace</code> да заменя всички инстанции, вместо само първата.</p>
<p><a class="p_ident" id="p_CW10Ac/SDj" href="./09_regexp.html#p_CW10Ac/SDj"></a>Конструктора <code>RegExp</code> може да се използва за създаване на регулярен израз със стойност <em>string</em>.</p>
<p><a class="p_ident" id="p_gsM3HikR5c" href="./09_regexp.html#p_gsM3HikR5c"></a>Регулярните изрази са остър инструмент с неудобна дръжка. Те опростяват някои задачи неимоверно, но могат бързо да станат трудни, когато се прилагат за сложни проблеми. Част от програмистите не занят как да ги използват и се съпротивляват на желанието да опитат да опростят нещата, когато не могат нормално да се изразяват с тях.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./09_regexp.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<p><a class="p_ident" id="p_meNfX2B/+s" href="./09_regexp.html#p_meNfX2B/+s"></a>Това е почти неизбежно, че в хода на работа по тези упражнения, вие ще се объркате и разочаровате от необяснимото поведение на някои регулярни изрази. Понякога помага да въведете вашия израз в онлайн инструмент, като <a href="https://www.debuggex.com/"><em>debuggex.com</em></a> за да видите дали неговата  визуализация съответства на това, което сте искали и да експериментирате с начина, по който реагира на различни входни <em>strings</em>.</p>
<h3><a class="h_ident" id="h_vDM8PzwQWU" href="./09_regexp.html#h_vDM8PzwQWU"></a>RegExp голф</h3>
<p><a class="p_ident" id="p_1t8xXpFN7O" href="./09_regexp.html#p_1t8xXpFN7O"></a>Код голф е термин използван за игра и се опитва да изрази конкретна програма в няколко характера, ако е възможно. По същия начин <em>regexp golf</em> е практика при писане на малък регулярен израз, който ако е възможно да съвпадне с определен модел и само с този модел.</p>
<p><a class="p_ident" id="p_VGCqgCur6C" href="./09_regexp.html#p_VGCqgCur6C"></a>За всяка от следните позиции, напишете регулярен израз, който да тества дали някой от дадените <em>substrings</em> се среща в <em>string</em>. Регулярният израз трябва да съвпада само с <em>strings</em>, съдържащ един от описаните <em>substrings</em>. Не се притеснявайте за думи граници, освен ако изрично не е описано. Когато вашия израз работи, вижте дали можете да гo направите по-малък.</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p><a class="p_ident" id="p_togdFO+/b9" href="./09_regexp.html#p_togdFO+/b9"></a>
<em>car</em> and <em>cat</em>
</p>
</li>
<li>
<p><a class="p_ident" id="p_2Q37Tsr9DS" href="./09_regexp.html#p_2Q37Tsr9DS"></a>
<em>pop</em> and <em>prop</em>
</p>
</li>
<li>
<p><a class="p_ident" id="p_2Ah4dFikw1" href="./09_regexp.html#p_2Ah4dFikw1"></a>
<em>ferret</em>, <em>ferry</em>, and <em>ferrari</em>
</p>
</li>
<li>
<p><a class="p_ident" id="p_ttiBCcePDl" href="./09_regexp.html#p_ttiBCcePDl"></a>
Any word ending in <em>ious</em>
</p>
</li>
<li>
<p><a class="p_ident" id="p_XnqTy5SopM" href="./09_regexp.html#p_XnqTy5SopM"></a>
A whitespace character followed by a dot, comma, colon, or semicolon
</p>
</li>
<li>
<p><a class="p_ident" id="p_Ku7hE3qqDn" href="./09_regexp.html#p_Ku7hE3qqDn"></a>
A word longer than six letters
</p>
</li>
<li>
<p><a class="p_ident" id="p_2Tx4SPp5Wm" href="./09_regexp.html#p_2Tx4SPp5Wm"></a>
A word without the letter <em>e</em>
</p>
</li>
</ol></div>
<p><a class="p_ident" id="p_Tzjl1Axr+h" href="./09_regexp.html#p_Tzjl1Axr+h"></a>Вижте таблицата в резюмето на <a href="./09_regexp.html#summary_regexp">главата за помощ</a>. Тествайте всяко решение с няколко тест <em>strings</em>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PjFdBrmWuQ" href="./09_regexp.html#c_PjFdBrmWuQ"></a><span class="cm-comment">// Fill in the regular expressions</span>

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"my car"</span>, <span class="cm-string">"bad cats"</span>],
       [<span class="cm-string">"camper"</span>, <span class="cm-string">"high art"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"pop culture"</span>, <span class="cm-string">"mad props"</span>],
       [<span class="cm-string">"plop"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"ferret"</span>, <span class="cm-string">"ferry"</span>, <span class="cm-string">"ferrari"</span>],
       [<span class="cm-string">"ferrum"</span>, <span class="cm-string">"transfer A"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"how delicious"</span>, <span class="cm-string">"spacious room"</span>],
       [<span class="cm-string">"ruinous"</span>, <span class="cm-string">"consciousness"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"bad punctuation ."</span>],
       [<span class="cm-string">"escape the dot"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"hottentottententen"</span>],
       [<span class="cm-string">"no"</span>, <span class="cm-string">"hotten totten tenten"</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">"red platypus"</span>, <span class="cm-string">"wobbling nest"</span>],
       [<span class="cm-string">"earth bed"</span>, <span class="cm-string">"learning ape"</span>]);


<span class="cm-keyword">function</span> <span class="cm-variable">verify</span>(<span class="cm-def">regexp</span>, <span class="cm-def">yes</span>, <span class="cm-def">no</span>) {
  <span class="cm-comment">// Ignore unfinished exercises</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">source</span> <span class="cm-operator">==</span> <span class="cm-string">"..."</span>) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">yes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failure to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
  <span class="cm-variable-2">no</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Unexpected match for '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
  });
}</pre>
<h3><a class="h_ident" id="h_dTiEW14oG0" href="./09_regexp.html#h_dTiEW14oG0"></a>Цитати - стил</h3>
<p><a class="p_ident" id="p_Zvl6rHT09m" href="./09_regexp.html#p_Zvl6rHT09m"></a>Представете си, че сте написали една история и използвате единични кавички за да отбележите парчета диалог. Сега искате да замените всички цитати на диалога с двойни кавички, като запазите единичните кавички използвани, като знак за съкращение.</p>
<p><a class="p_ident" id="p_k3Y0NF9w4b" href="./09_regexp.html#p_k3Y0NF9w4b"></a>Помислете за модел, който разграничава тези два вида ползване на цитати и направете извикване към <code>replace</code> метода, който да направи правилно замяната.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_KNcaojz4vQ" href="./09_regexp.html#c_KNcaojz4vQ"></a><span class="cm-keyword">var</span> <span class="cm-variable">text</span> <span class="cm-operator">=</span> <span class="cm-string">"'I'm the cook,' he said, 'it's my job.'"</span>;
<span class="cm-comment">// Change this call.</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/A/g</span>, <span class="cm-string">"B"</span>));
<span class="cm-comment">// → "I'm the cook," he said, "it's my job."</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_rNoBQVCfFp" href="./09_regexp.html#p_rNoBQVCfFp"></a>Най-очевидното решение е да се заменят само цитатите с <em>nonword</em> характери поне на едната страна. Нещо, подобно на <code>/\W'|'\W/</code>. Но вие също трябва да се вземе началото и края на реда под внимание.</p>
<p><a class="p_ident" id="p_1SUsrUgWek" href="./09_regexp.html#p_1SUsrUgWek"></a>В допълнение, трябва да сте сигурни, че замяната включва характери, които съответстват на <code>\W</code> модела, така че да не се пропуснат. Това може да се направи, като ги опаковате в скоби включително и техните групи в заместващ <em>string</em> (<code>$1</code>, <code>$2</code>). Групи, които не се покриват няма да бъдат заменени с нищо.</p>
</div></div>
<h3><a class="h_ident" id="h_izldJoT3uv" href="./09_regexp.html#h_izldJoT3uv"></a>Отново номера</h3>
<p><a class="p_ident" id="p_2Z15nSCOWO" href="./09_regexp.html#p_2Z15nSCOWO"></a>Серия от цифри могат да бъдат съчетани с прост регулярен израз <code>/\d+/</code>.</p>
<p><a class="p_ident" id="p_4ILW7h/ou4" href="./09_regexp.html#p_4ILW7h/ou4"></a>Напишете израз, който съвпада само с JavaScript-стил номера. Той трябва да подържа незадължителните характери  плюс + и минус - в предната част на числото, след десетичната точка и експонента нотацията - <code>5e-3</code> или <code>1E10</code> - отново  с допълнителен характер пред експонентата. Също така, имайте предвид, че не е необходимо да има цифри пред или след точката, но броят им не може да бъде само една точка. Това означава, че <code>.5</code> и <code>5.</code> са валидни номера в JavaScript, но само точка не е.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_svZIRqtX/7" href="./09_regexp.html#c_svZIRqtX/7"></a><span class="cm-comment">// Fill in this regular expression.</span>
<span class="cm-keyword">var</span> <span class="cm-variable">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^...$/</span>;

<span class="cm-comment">// Tests:</span>
[<span class="cm-string">"1"</span>, <span class="cm-string">"-1"</span>, <span class="cm-string">"+15"</span>, <span class="cm-string">"1.55"</span>, <span class="cm-string">".5"</span>, <span class="cm-string">"5."</span>, <span class="cm-string">"1.3e2"</span>, <span class="cm-string">"1E-4"</span>,
 <span class="cm-string">"1e+12"</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to match '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});
[<span class="cm-string">"1a"</span>, <span class="cm-string">"+-1"</span>, <span class="cm-string">"1.2.3"</span>, <span class="cm-string">"1+1"</span>, <span class="cm-string">"1e4.5"</span>, <span class="cm-string">".5."</span>, <span class="cm-string">"1f5"</span>,
 <span class="cm-string">"."</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">s</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">s</span>))
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Incorrectly accepted '"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">s</span> <span class="cm-operator">+</span> <span class="cm-string">"'"</span>);
});</pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_vkoPQ1fhR2" href="./09_regexp.html#p_vkoPQ1fhR2"></a>На първо място, не забравяйте обратно наклонената черта преди точката.</p>
<p><a class="p_ident" id="p_ShOca+aF11" href="./09_regexp.html#p_ShOca+aF11"></a>Съвпадението с незадължителен характер преди номер, както и преди експонента, може да се направи със <code>[+\-]?</code> или <code>(\+|-|)</code> (плюс, минус или нищо).</p>
<p><a class="p_ident" id="p_z9QJjd6IxQ" href="./09_regexp.html#p_z9QJjd6IxQ"></a>Най-сложната част от упражнението е проблема със съвпадението на двете <code>"5."</code> и <code>".5"</code> без да съвпада с точката <code>"."</code>. За тази цел, добро решение е да използвате оператора <code>|</code> да се разделят двата случая - една или повече цифри по желание последвани от точка и нула или повече цифри или точка, последвани от една или повече цифри.</p>
<p><a class="p_ident" id="p_XC+73LgOvD" href="./09_regexp.html#p_XC+73LgOvD"></a>И накрая, за да се влияе от случая или добавете <code>i</code> опция за регулярния израз или използвайте <code>[eE]</code>.</p>
</div></div>
<nav>
  <a href="./08_error.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./10_modules.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>