<!DOCTYPE html>
<!-- saved from url=(0045)./10_modules.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Modules :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 10;var sandboxLoadFiles = ["code/chapter/10_modules.js", "code/loadfile.js"];</script>
</head>

<body><article>
<nav>
  <a href="./09_regexp.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./11_language.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 10</div>Модули</h1>
<blockquote>
<p><a class="p_ident" id="p_PJiK2g1JXC" href="./10_modules.html#p_PJiK2g1JXC"></a>Начинаещ програмист пише своите програми, както една мравка изгражда хълм, като една цяла част наведнъж, без да мисли за по-голяма структура. Неговите програми ще бъдат, като хлабав пясък. Те могат да издържат известно време, но ако растат прекалено големи и ще се разпаднат.</p>
<p><a class="p_ident" id="p_OfZWeuo+oF" href="./10_modules.html#p_OfZWeuo+oF"></a>Осъзнавайки този проблем, програмиста ще започне да прекарва много време мислейки за структурата. Неговите програми ще бъдат неподвижно структурирани, като скални скулптори. Те са солидни, но когато трябва да се променят, ще трябва да се приложи усилие.</p>
<p><a class="p_ident" id="p_fFMEGH1dk3" href="./10_modules.html#p_fFMEGH1dk3"></a>Майсторът програмист, знае кога да прилага структура и кога да остави нещата в тяхната проста форма. Неговите програми, са като глина, стегнати и същевременно ковки.”</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_1aMUBkVbPd" href="./10_modules.html#p_1aMUBkVbPd"></a>Всяка програма има форма. В малък мащаб, тази форма се определя чрез разделяне на функции и блоковете вътре в тези функции. Програмистите имат много свобода в начина, по който да структурират своите програми. Формата следва повече вкуса на програмиста, отколкото предназначената функционалност на програмата.</p>
<p><a class="p_ident" id="p_NOETmtvWWx" href="./10_modules.html#p_NOETmtvWWx"></a>Когато гледате в по-голяма програма, която е цяла, отделни функции започват да се смесват с фона. Такива програми може да се направят по-разбираеми, ако имате по-добър начин за организация.</p>
<p><a class="p_ident" id="p_07zdYJYQ1M" href="./10_modules.html#p_07zdYJYQ1M"></a>Модулите разделят програми в групи от код, които по някакъв критерий са свързани заедно. Тази глава разглежда някои от ползите, които това разделяне осигурява и показва техники за изграждане на модули в JavaScript.</p>
<h2><a class="h_ident" id="h_0DSW4+9YVh" href="./10_modules.html#h_0DSW4+9YVh"></a>Защо  модулите  помагат</h2>
<p><a class="p_ident" id="p_ovuaejexnJ" href="./10_modules.html#p_ovuaejexnJ"></a>Има редица причини, поради които, автори разделят своите книги в глави и раздели. Тези разделения правят по-лесно за едни читател да види как е изградена книгата и да намира конкретни части от нея, които го интересуват. Те също помагат на автора, като му предоставят ясен фокус за всеки раздел.</p>
<p><a class="p_ident" id="p_QxCtWUR2zJ" href="./10_modules.html#p_QxCtWUR2zJ"></a>Ползите от организиране на програма в няколко файла или модули са сходни. Структурата помага на хората, които все още не са запознати с кода, да намират това, което търсят и прави по-лесно за програмист да пази неща, които са тясно свързани заедно.</p>
<p><a class="p_ident" id="p_4vnN7lCDZy" href="./10_modules.html#p_4vnN7lCDZy"></a>Някои програми дори са организирани по модел на традиционен текст с ясно определена цел, с която читателя се насърчава да мине през програмата и с много проза (коментари) въвежда последоватено в описанието на кода. Това прави четенето на програмата много по-малко смущаващо, отколкото четене на неизвестен код, но има недостатък, който е повечето работа за да се създаде. Този стил се нарича грамотно програмиране. Проектите в тази книга могат да се считат за грамотни програми.</p>
<p><a class="p_ident" id="p_Ou/d4KbIy/" href="./10_modules.html#p_Ou/d4KbIy/"></a>Като общо правило, структурирането на нещата има разходи на енергия. В ранните етапи на един проект, когато още не сте съвсем сигурни какво, къде или от какъв вид модули се нуждае програмата, аз подкрепям минималистичния безструктурен подход. Просто сложете всичко там, където ви е удобно, докато стабилизирате кода. По този начин, вие няма да губите време за преместване на части от програмата назад - напред и няма да се заключите случайно в конструкция, която всъщност не е част от вашата програма.</p>
<h3><a class="h_ident" id="h_NitCO6r9Hn" href="./10_modules.html#h_NitCO6r9Hn"></a>Namespacing</h3>
<p><a class="p_ident" id="p_8S/+Hon3uA" href="./10_modules.html#p_8S/+Hon3uA"></a>Повечето съвременни езици за програмиране имат ниво на обхват между глобалното (видимо от всеки) и локално (видимо от функцията в която е), JavaScript няма такъв обхват. По този начин, по подразбиране, всичко което трябва да се вижда извън обхвата на функцията се вижда на всякъде до най-високото ниво.</p>
<p><a class="p_ident" id="p_QMB7RIsBay" href="./10_modules.html#p_QMB7RIsBay"></a>Именно проблемът със <code>namespace</code> замърсяването с много несвързан код, налага да се споделя единен набор от глобални имена на променливи, за което споменахме в <a href="./04_data.html#namespace_pollution">Глава 4</a>, където обекта <code>Math</code> беше даден, като пример за обект, който действа, като модул чрез групиране на свързана с математиката функционалност.</p>
<p><a class="p_ident" id="p_bBKNVkrywA" href="./10_modules.html#p_bBKNVkrywA"></a>Въпреки, че JavaScript не предвижда изграждане на действителен модул все още, обектите могат да бъдат използвани за създаване на публично достъпни <em>subnamespaces</em> и функциите могат да се използват за създаване на изолирано, лично пространство във вътрешността на модула. По късно в тази глава, аз ще обсъдя начин за изграждане на разумно и удобно  изолиране на <code>namespace</code> за модули върху примитивните концепции, които JavaScript ни дава.</p>
<h3><a class="h_ident" id="h_UuxJID5Z2e" href="./10_modules.html#h_UuxJID5Z2e"></a>Повторна  употреба</h3>
<p><a class="p_ident" id="p_0MwF7DbAP0" href="./10_modules.html#p_0MwF7DbAP0"></a>В “плосък” проект, който не е структуриран, като набор от модули, не е ясно кои части от кода са нужни, за да се използва определена функция. В моята програма за шпиониране на враговете (виж <a href="./09_regexp.html#ini">Глава 9</a>), аз написах функция за четене на конфигурационни файлове. Ако искам да използвам тази функция в друг проект, трябва да отида и да копирам частите от старата програма, от които имам нужда свързани с функционалноста и да ги поставя в новата си програма. След това, ако намеря грешка в кода, аз ще го оправя само в зависимост от това в коя програма работя в момента и най-вероятно ще забравя да го оправя в другата програма.</p>
<p><a class="p_ident" id="p_n5Itkf6SsY" href="./10_modules.html#p_n5Itkf6SsY"></a>След като, имате много такива споделени, дублирани парчета код, постепенно ще откриете, че губите много време и енергия за да ги местите и съхранявате.</p>
<p><a class="p_ident" id="p_zwgHmRoxk9" href="./10_modules.html#p_zwgHmRoxk9"></a>Поставянето на самостоятелни парчета функционалност в отделни файлове и модули ги прави по-лесно проследими за обновяване и споделяне, защото всички различни части от кода, който искате да използвате, като модул са заредени от същия действителен файл.</p>
<p><a class="p_ident" id="p_D2yYhnbA9K" href="./10_modules.html#p_D2yYhnbA9K"></a>Тази идея получава още мощност, когато отношенията между модулите - това кой модул от кой зависи - са изрично определени. След това можете да автоматизирате процеса за инсталиране и обновяване на външни модули (библиотеки).</p>
<p><a class="p_ident" id="p_3ED8vjm59N" href="./10_modules.html#p_3ED8vjm59N"></a>Разширявайки тази идея още повече, си представете онлайн услуга, която следи и разпределя стотици хиляди библиотеки, което ви позволява да търсите функционалноста, от която имате нужда и след като я намерите, вашия проект автоматично да я изтегли.</p>
<p id="modules_npm"><a class="p_ident" id="p_8hHGZUvmtE" href="./10_modules.html#p_8hHGZUvmtE"></a>Такава услуга съществува. Тя се нарича NPM (<a href="http://npmjs.org/"><em>npmjs.org</em></a>). NPM се състои от онлайн база данни на модули и инструмент за изтегляне и обновяване на модулите, от които зависи вашата програма. Тя се роди в резултат на Node.js среда за JavaScript, която ще обсъдим в 
<a href="./20_node.html#node">Глава 20</a>, но може да бъде полезна при програмирането за браузъра.</p>
<h3><a class="h_ident" id="h_qJacYNwWWL" href="./10_modules.html#h_qJacYNwWWL"></a>Отделяне</h3>
<p><a class="p_ident" id="p_BIr3LxVodJ" href="./10_modules.html#p_BIr3LxVodJ"></a>Друга важна роля на модулите е изолирането на части от код от друг, по същия начин, който интерфейсите на обектите правят в <a href="./06_object.html#interface">Глава 6</a>. Един добре проектиран модул ще предостави интерфейс за външен код, за да може да се използва. Тъй като, модулът получава актуализация с корекции и нова функционалност, съществуващият интерфейс остава същия (ако е стабилен), така че и други модули да могат да използват новата подобрена версия без никакви промени в себе си.</p>
<p><a class="p_ident" id="p_B3JCtLjLbo" href="./10_modules.html#p_B3JCtLjLbo"></a>Имайте в предвид, че един стабилен интерфейс не означава, че няма нови функции, методи или променливи, които да се добавят към него. Това просто означава, че съществуващата функционалност не е отстранена и нейното значение не се променя.</p>
<p><a class="p_ident" id="p_vcubl5qb7a" href="./10_modules.html#p_vcubl5qb7a"></a>Един добър интерфейс за модул трябва да даде възможност на модула да расте без да се счупи стария интерфейс. Това означава, че излагайки някои от вътрешните концепции на модула, прави този интерфейс по-мощен и достатъчно гъвкав, за да се прилага в широк спектър от ситуации.</p>
<p><a class="p_ident" id="p_jT10dBy1PO" href="./10_modules.html#p_jT10dBy1PO"></a>За интерфейси, които излагат  единна, фиксирана концепция, като четец на конфигурационен файл, този дизайн идва естествено. За други, като текстов редактор, който има много различни аспекти, които се нуждаят от външен код за достъп(съдържание, стайлинг, действия на потребител и т.н.) се изисква внимателно планиране.</p>
<h2><a class="h_ident" id="h_FIe+oM6Cvt" href="./10_modules.html#h_FIe+oM6Cvt"></a>Използване  на  функциии, като namespaces</h2>
<p><a class="p_ident" id="p_Qi0v4Dtc05" href="./10_modules.html#p_Qi0v4Dtc05"></a>Функциите са единствените неща в JavaScript, които създават нов обхват. Така че, ако искаме нашите модули да имат свой собствен характер, ще трябва да ги основем на функции.</p>
<p><a class="p_ident" id="p_TJhIvzABX+" href="./10_modules.html#p_TJhIvzABX+"></a>Помислете за този тривиален модул, за асоцииране на имена с номера за дните от седмицата, върнати от <code>getDay</code> метода на <code>Date</code> обекта:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_0/+3DgqC3k" href="./10_modules.html#c_0/+3DgqC3k"></a><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
<span class="cm-keyword">function</span> <span class="cm-variable">dayName</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p><a class="p_ident" id="p_lljN2eMCck" href="./10_modules.html#p_lljN2eMCck"></a>Функцията <code>dayName</code> е част от интерфейса на модула, но променливата <code>names</code> не е. Бихме предпочели да не я изсипваме в глобалния обхват.</p>
<p><a class="p_ident" id="p_NKmpNxgsFg" href="./10_modules.html#p_NKmpNxgsFg"></a>Можем да направим това:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cQrjXVzz5t" href="./10_modules.html#c_cQrjXVzz5t"></a><span class="cm-keyword">var</span> <span class="cm-variable">dayName</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">3</span>));
<span class="cm-comment">// → Wednesday</span></pre>
<p><a class="p_ident" id="p_wFyqiGP0o5" href="./10_modules.html#p_wFyqiGP0o5"></a>Сега <code>names</code> е локална променлива в (анонимна) функция. Тази функция се създава и веднага се извиква и нейната върната стойност (действителната <code>dayName</code> функция) се съхранява в променлива. Ние можем да имаме страници и страници код в тази функция, със сто локални променливи и всички те ще бъдат вътрешени за нашия модул, видими за самия модул, но невидими от външния код.</p>
<p><a class="p_ident" id="p_XMMYXbTqGr" href="./10_modules.html#p_XMMYXbTqGr"></a>Можем да използваме подобен модел да изолираме код изцяло от външния свят. Следващия модул регистрира стойност на конзолата, но всъщност не предоставя никакви стойности за ползване към други модули.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HzELhaatCS" href="./10_modules.html#c_HzELhaatCS"></a>(<span class="cm-keyword">function</span>() {
  <span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
  <span class="cm-keyword">var</span> <span class="cm-def">hundred</span> <span class="cm-operator">=</span> <span class="cm-number">100</span>;

  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">square</span>(<span class="cm-variable-2">hundred</span>));
})();
<span class="cm-comment">// → 10000</span></pre>
<p><a class="p_ident" id="p_NhLZMeErEJ" href="./10_modules.html#p_NhLZMeErEJ"></a>Този код просто извежда квадрата на 100, но в реалния свят това може да бъде един модул, който добавя метод към някой прототип или създава нещо в уеб страница. Той е увит във функция, за да попречи на променливите, които използва вътрешно да замърсят глобалния обхват.</p>
<p><a class="p_ident" id="p_TMPi6xxW7Y" href="./10_modules.html#p_TMPi6xxW7Y"></a>Защо увиваме <em>namespace</em> функциите в чифт скоби? Това е свързано с приумица в синтаксиса на JavaScript. Ако израза започва с ключовата дума <code>function</code>, това е функционален израз. Обаче, ако изявление започва с <code>function</code>, това е декларация на функция, която изисква име и не е израз, който може да се извика, като се напишат скоби след него. Може да мислите за допълнителните увиващи скоби, като трик да се принуди функцията да се тълкува, като израз.</p>
<h2><a class="h_ident" id="h_tbrMjRcajd" href="./10_modules.html#h_tbrMjRcajd"></a>Обекти,  като интерфейс</h2>
<p><a class="p_ident" id="p_jaxyyZ13ux" href="./10_modules.html#p_jaxyyZ13ux"></a>Сега си представете, че искаме да добавим още една функция в нашия модул на седмицата, която прехвърля името на деня в номер. Не можем просто да върнем функция вече, трябва да увием двете функции в един обект.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_j+iqUdoU2O" href="./10_modules.html#c_j+iqUdoU2O"></a><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Sunday"</span>)));
<span class="cm-comment">// → Sunday</span></pre>
<p><a class="p_ident" id="p_67L/Eo8MtL" href="./10_modules.html#p_67L/Eo8MtL"></a>За по-големи модули, събирането на всички изнасяни стойности в обект в края на функцията, става неудобно, тъй като много от изнесените функции има вероятност да бъдат големи и предпочитаме да ги напишем някъде другаде, свързани с вътрешен код. Удобна алтернатива е да се направи обект (условно наречен <code>exports</code>) и да добавим свойства за всеки път, когато определяме нещо, което трябва да бъде изнесено. В следващия пример, модул функцията взема интерфейс на обект, като аргумент, позволявайки на кода извън функцията да го създаде и съхранява в променлива. (Извън функцията, <code>this</code> се отнася до глобалния обхват на обекта).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qHa2RFvopi" href="./10_modules.html#c_qHa2RFvopi"></a>(<span class="cm-keyword">function</span>(<span class="cm-def">exports</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

  <span class="cm-variable-2">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
  <span class="cm-variable-2">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
  };
})(<span class="cm-keyword">this</span>.<span class="cm-property">weekDay</span> <span class="cm-operator">=</span> {});

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Saturday"</span>)));
<span class="cm-comment">// → Saturday</span></pre>
<h2><a class="h_ident" id="h_ryZfYeSnJy" href="./10_modules.html#h_ryZfYeSnJy"></a>Отделяне  от  глобалния  обхват</h2>
<p><a class="p_ident" id="p_AfCtO+ifwZ" href="./10_modules.html#p_AfCtO+ifwZ"></a>Предишният модел обикновено се използва от JavaScript модули, предназначени за браузъра. Модулът ще регистрира една глобална променлива и ще увие нейния код във функция, така че да има свое собствено <em>namespace</em>. Но този модел все още създава проблеми, ако се случи множество модули да имат претенция към същото име или ако искате да заредите две версии на даден модул успоредно една до друга.</p>
<p><a class="p_ident" id="p_Y2ejGOe+u4" href="./10_modules.html#p_Y2ejGOe+u4"></a>С малко връзки, можем да създадем система, която позволява на един модул да поиска директно интерфейса на обект от друг модул, без да минава през глобалния обхват. Нашата цел е <code>require</code> функция, на която, когато се подаде името на модула, ще зареди файл (от диск или от мрежата, в зависимост от платформата върху ще се изпълнява) и ще върне съответната стойност на интерфейса.</p>
<p><a class="p_ident" id="p_6BOb5Vhxc7" href="./10_modules.html#p_6BOb5Vhxc7"></a>Този подход решава проблемите, споменати по-рано и има допълнителна полза за вземане на зависимости в нашата програма, което прави трудно случайно да се използва някой друг модул без да се посочва, че имаме нужда от него.</p>
<p><a class="p_ident" id="p_qsfTCs+Kiu" href="./10_modules.html#p_qsfTCs+Kiu"></a>За <code>require</code> имаме нужда от две неща. Първо ни трябва функция <code>readFile</code>, която връща съдържанието на даден файл, като <em>string</em>. (Тази функция не е налична в стандартния JavaScript, но различни среди за JavaScript, като браузър и Node.js, предоставят свои собствени начини за достъп до файловете. За сега нека просто се преструваме, че имаме тази функция.) Второ, трябва действително да можем да изпълним този <em>string</em>, като JavaScript код.</p>
<h2 id="eval"><a class="h_ident" id="h_oeOkEDaadU" href="./10_modules.html#h_oeOkEDaadU"></a>Оценяване  на  данни,  като  код</h2>
<p><a class="p_ident" id="p_jvij1au4eP" href="./10_modules.html#p_jvij1au4eP"></a>Има няколко начина да се вземат данни от <em>string</em> код и да се стартират, като част от настоящата програма.</p>
<p><a class="p_ident" id="p_sQ1ASk7W7E" href="./10_modules.html#p_sQ1ASk7W7E"></a>Най-очевидният начин е със специалният оператор <code>eval</code>, който ще изпълни поредицата от код в текущия обхват. Това обикновено е лоша идея, защото ще се разпадне от някое от нормалните свойства, които обикновено имат обхват, когато се изолират от външния свят.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_RanI4EdsYD" href="./10_modules.html#c_RanI4EdsYD"></a><span class="cm-keyword">function</span> <span class="cm-variable">evalAndReturnX</span>(<span class="cm-def">code</span>) {
  <span class="cm-variable">eval</span>(<span class="cm-variable-2">code</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">x</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evalAndReturnX</span>(<span class="cm-string">"var x = 2"</span>));
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_dJLBESQexx" href="./10_modules.html#p_dJLBESQexx"></a>По добър начин за интерпретиране на данни, като код, е да се използва <code>Function</code> конструктора. Той взема два аргумента: <em>string</em>, съдържащ разделен със запетаи списък от имена на аргументи и <em>string</em>, съдържащ тяло на функция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cZ4LeZbFGl" href="./10_modules.html#c_cZ4LeZbFGl"></a><span class="cm-keyword">var</span> <span class="cm-variable">plusOne</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"n"</span>, <span class="cm-string">"return n + 1;"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">plusOne</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 5</span></pre>
<p><a class="p_ident" id="p_8DGWg5jk7v" href="./10_modules.html#p_8DGWg5jk7v"></a>Това е точно онова, от което имаме нужда за нашите модули. Ние можем просто да увием кода на модула в една функция и обхвата на тази функция да стане обхвата на нашия модул.</p>
<h2 id="commonjs"><a class="h_ident" id="h_v/XE3QWFpP" href="./10_modules.html#h_v/XE3QWFpP"></a>Require</h2>
<p><a class="p_ident" id="p_hpfd8nPIk6" href="./10_modules.html#p_hpfd8nPIk6"></a>Следващото е минимално изпълнение на <code>require</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1+P7EyFe1w" href="./10_modules.html#c_1+P7EyFe1w"></a><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">exports</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>).<span class="cm-property">name</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p><a class="p_ident" id="p_JrILpUgcrH" href="./10_modules.html#p_JrILpUgcrH"></a>Тъй като, <code>new Function</code> конструктора увива кодa на модула във функция, ние не трябва да пишем функция за опаковане на <em>namespace</em> функция в самия файл на модула. И тъй като, правим <code>exports</code> аргумент за модул функцията, самия модул не трябва да го декларира. Това премахва много елементарни неща от нашия примерен модул.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_UcVUK3ap0Z" href="./10_modules.html#c_UcVUK3ap0Z"></a><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

<span class="cm-variable">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
};
<span class="cm-variable">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
};</pre>
<p><a class="p_ident" id="p_B75dGyOs9V" href="./10_modules.html#p_B75dGyOs9V"></a>Когато използваме този модел, един модул обикновено започва с няколко декларации на променливи, от които модулите зависят.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hczzYLixJt" href="./10_modules.html#c_hczzYLixJt"></a><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">today</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"today"</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">today</span>.<span class="cm-property">dayNumber</span>()));</pre>
<p><a class="p_ident" id="p_5GfcRhlMLC" href="./10_modules.html#p_5GfcRhlMLC"></a>Опростеното изпълнение на <code>require</code> дадено преди това, има няколко проблема. От една страна, то ще зареди и стартира модул всеки път, когато се извиква <code>require</code>, така че ако няколко модула имат същата зависимост или извикването към <code>require</code> се постави вътре във функция, която се извиква многократно, се губи време и енергия.</p>
<p><a class="p_ident" id="p_zLUwyIBMDV" href="./10_modules.html#p_zLUwyIBMDV"></a>Това може да бъде решено чрез съхраняване на модулите, които вече са заредени в обект и просто връщаме съществуващата стойност, когато е заредена многократно.</p>
<p><a class="p_ident" id="p_Ylx5bX6l+o" href="./10_modules.html#p_Ylx5bX6l+o"></a>Вторият проблем е, че не е възможно за модул да изнася директно стойност, различна от <code>exports</code> обекта, като функция. Например, от един модул може да искате да експортирате само конструктора на типа на обекта, който го дефинира. Точно сега, той не може да направи това, защото <code>require</code> винаги използва <code>exports</code> обекта, който създава експортната стойност.</p>
<p><a class="p_ident" id="p_RwxY5rq2Qj" href="./10_modules.html#p_RwxY5rq2Qj"></a>Традиционното решение за това е да се осигури модул с друга променлива <code>module</code>, която е обект, който има свойството <code>exports</code>. Това свойство първоначално посочва празен обект, създаден от <code>require</code>, но може да бъде заменен с друга стойност, за да експортира нещо друго.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cUUt/BCrSf" href="./10_modules.html#c_cUUt/BCrSf"></a><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports, module"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {}, <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-variable-2">exports</span>};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>, <span class="cm-keyword">module</span>);

  <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
}
<span class="cm-variable">require</span>.<span class="cm-property">cache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);</pre>
<p><a class="p_ident" id="p_Dv+TulRay7" href="./10_modules.html#p_Dv+TulRay7"></a>Сега имаме модулна система, която използва една глобална променлива (<code>require</code>), за да позволи на модулите да се намират и използват взаимно, без да минават през глобалния обхват.</p>
<p><a class="p_ident" id="p_rvZ9T+1c9y" href="./10_modules.html#p_rvZ9T+1c9y"></a>Този стил на модулна система се нарича <em>CommonJS modules</em>, след псевдо стандарт, който пръв го е посочил. Тя е вградена система в Node.js. Реалните реализации правят много повече от примера, който показах. Най-важното е, че те имат много по-интелигентен начин за преминаване на модул към действителна част на код, който позволява и двете: пътища и файлове, по отношение на текущите файлове и имена на модули, които сочат директно към локално инсталираните модули.</p>
<h2 id="amd"><a class="h_ident" id="h_A4LDSlASUo" href="./10_modules.html#h_A4LDSlASUo"></a>Бавно  зареждане  на  модули</h2>
<p><a class="p_ident" id="p_isvKkfyGNv" href="./10_modules.html#p_isvKkfyGNv"></a>Въпреки, че е възможно използването на CommonJS стил при писане на JavaScript за браузъри, той е малко по-ангажиращ. Причината за това е, че четенето на файл (модул) от Интернет е малко по-бавно, отколкото четене от твърдия диск. Докато скрипт се изпълнява в браузъра, нищо друго не може да се случи на интернет страницата, на която той работи, по причини които ще станат известни в <a href="./14_event.html#timeline">Глава 14</a>. Това означава, че при всяко извикване на <code>require</code> да отиде и извади нещо от някакъв далечен уеб сървър, страницата ще замръзне за болезнено дълго време при зареждането на скриптовете.</p>
<p><a class="p_ident" id="p_Ce7X8+/o7v" href="./10_modules.html#p_Ce7X8+/o7v"></a>Един начин да се справите с този проблем е да стартирате програма, като <a href="http://browserify.org/"><em>Browserify</em></a> в кода си, преди да сте го връчили на уеб страницата. Тя ще гледа за извиквания към <code>require</code>, решавайки всички зависимости и събирайки необходимия код в един голям файл. В самия сайт просто може да се зареди този файл, за да получи всички модули, от които се нуждае.</p>
<p><a class="p_ident" id="p_L9zjrOe2Un" href="./10_modules.html#p_L9zjrOe2Un"></a>Друго решение е да увиете кода, който изгражда вашия модул във функция, така че програмата за зареждане на модул, първо да зареди неговите зависимости във фонов режим и след това да извика функцията за инициализиране на модул, след като зависимостите са вече заредени. Това е системата за асинхронни модули - Asynchronous Module Definition (AMD).</p>
<p><a class="p_ident" id="p_69ZNnLLNhP" href="./10_modules.html#p_69ZNnLLNhP"></a>Нашата тривиална програма със зависимости, ще изглежда така в AMD:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+VGbHf95V3" href="./10_modules.html#c_+VGbHf95V3"></a><span class="cm-variable">define</span>([<span class="cm-string">"weekDay"</span>, <span class="cm-string">"today"</span>], <span class="cm-keyword">function</span>(<span class="cm-def">weekDay</span>, <span class="cm-def">today</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable-2">today</span>.<span class="cm-property">dayNumber</span>()));
});</pre>
<p><a class="p_ident" id="p_/aD387r6Uv" href="./10_modules.html#p_/aD387r6Uv"></a>Функцията <code>define</code> е в центъра на този подход. Тя взема първия модул с масив от имена и след това функция, която приема само един аргумент за всяка зависимост. Тя ще зареди зависимостите(ако още не са заредени) във фонов режим, което позволява на страницата да продължи да работи, докато файловете се изтеглят. След като, всички зависимости са заредени, <code>define</code> ще извика функцията, която и е дадена, с интерфейсите на тези зависимости, като аргументи.</p>
<p><a class="p_ident" id="p_w7/Slpc0XV" href="./10_modules.html#p_w7/Slpc0XV"></a>Модулите, които се зареждат по този начин трябва да съдържат извикване към <code>define</code>. Стойността, която се използва за техния интерфейс е тази, която се връща от функцията подадена към <code>define</code>. Сега тука е модулът <code>weekDay</code> отново:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cye5TZvdJH" href="./10_modules.html#c_cye5TZvdJH"></a><span class="cm-variable">define</span>([], <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
});</pre>
<p><a class="p_ident" id="p_GARnQl+u0i" href="./10_modules.html#p_GARnQl+u0i"></a>За да мога да покажа минимално изпълнение на <code>define</code>, ще се преструваме, че имаме <code>backgroundReadFile</code> функция, която взема име на файл и функция и извиква функцията със съдържанието на файла, веднага след, като приключи зареждането. (<a href="./17_http.html#getURL">Глава 17</a> ще ви обясня, как да пишете такива функции.)</p>
<p><a class="p_ident" id="p_xNPCNpRiIX" href="./10_modules.html#p_xNPCNpRiIX"></a>За проследяване на модулите, докато са натоварени, изпълнението на <code>define</code> ще използва обекти, които описват състоянието на модулите и ни казват дали те са на разположение и осигуряват техния интрефейс, когато са.</p>
<p><a class="p_ident" id="p_/Unllb03Bv" href="./10_modules.html#p_/Unllb03Bv"></a>Функцията <code>getModule</code>, когато и се даде име ще върне този обект и ще гарантира, че модулът планирано е зареден. Тя използва кеш обект, за да се избегне натоварване на същия модул два пъти.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hSHaK3C/lo" href="./10_modules.html#c_hSHaK3C/lo"></a><span class="cm-keyword">var</span> <span class="cm-variable">defineCache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;

<span class="cm-keyword">function</span> <span class="cm-variable">getModule</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">defineCache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-atom">null</span>,
                <span class="cm-property">loaded</span>: <span class="cm-atom">false</span>,
                <span class="cm-property">onLoad</span>: []};
  <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
  <span class="cm-variable">backgroundReadFile</span>(<span class="cm-variable-2">name</span>, <span class="cm-keyword">function</span>(<span class="cm-def">code</span>) {
    <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
    <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">""</span>, <span class="cm-variable-2">code</span>)();
  });
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>;
}</pre>
<p><a class="p_ident" id="p_r9NqByjA7c" href="./10_modules.html#p_r9NqByjA7c"></a>Предполагаме, че заредения файл съдържа също и (едно) извикване към <code>define</code>. Променливата <code>currentMod</code> се използва за да отрази това извикване към модул обекта, който в момента се зарежда, така че да може да се актуализира този обект, когато завърши зареждането. Ние ще се върнем на този механизъм в един момент.</p>
<p><a class="p_ident" id="p_lX37OjlA5W" href="./10_modules.html#p_lX37OjlA5W"></a>Самата функция <code>define</code> използва <code>getModule</code> за извличане или създаване на модул обекти за зависимостите на текущия модул. Нейната задача е да планира <code>moduleFunction</code> (функцията, която съдържа действителния код на модула) да се стартира, когато тези зависимости са заредени. За тази цел тя определя функцията <code>whenDepsLoaded</code>, която да добавя към <code>onLoad</code> масива всички зависимости, които все още не са заредени. Тази функция се връща незабавно, ако има все още незаредени зависимости, така че ще извърши действителната работа само веднъж, когато последната зависимост приключи със зареждането. Тя също така се извиква незабавно от самия <code>define</code> в случай, че няма зависимости, които трябва да бъдат заредени.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1c60YXnLU3" href="./10_modules.html#c_1c60YXnLU3"></a><span class="cm-keyword">function</span> <span class="cm-variable">define</span>(<span class="cm-def">depNames</span>, <span class="cm-def">moduleFunction</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">myMod</span> <span class="cm-operator">=</span> <span class="cm-variable">currentMod</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">deps</span> <span class="cm-operator">=</span> <span class="cm-variable-2">depNames</span>.<span class="cm-property">map</span>(<span class="cm-variable">getModule</span>);

  <span class="cm-variable-2">deps</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">mod</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">mod</span>.<span class="cm-property">loaded</span>)
      <span class="cm-variable-2">mod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">push</span>(<span class="cm-variable">whenDepsLoaded</span>);
  });

  <span class="cm-keyword">function</span> <span class="cm-def">whenDepsLoaded</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">deps</span>.<span class="cm-property">every</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">loaded</span>; }))
      <span class="cm-keyword">return</span>;

    <span class="cm-keyword">var</span> <span class="cm-def">args</span> <span class="cm-operator">=</span> <span class="cm-variable-2">deps</span>.<span class="cm-property">map</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">exports</span>; });
    <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">moduleFunction</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">args</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">myMod</span>) {
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">exports</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">loaded</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">f</span>) { <span class="cm-variable-2">f</span>(); });
    }
  }
  <span class="cm-variable-2">whenDepsLoaded</span>();
}</pre>
<p><a class="p_ident" id="p_T+RexzI7A0" href="./10_modules.html#p_T+RexzI7A0"></a>Когато всички зависимости са на разположение, <code>whenDepsLoaded</code> извиква функция, която държи модула, като му дава интерфейси на зависимостите, като аргументи.</p>
<p><a class="p_ident" id="p_8Neb8ba81Q" href="./10_modules.html#p_8Neb8ba81Q"></a>Първото нещо, което <code>define</code> прави е да съхрани стойността, която <code>currentMod</code> имa, когато е извикан в променливата <code>myMod</code>. Не забравяйте, че <code>getModule</code> точно преди оценяването на кода за модула, съхранява съответния модул обект в <code>currentMod</code>. Това позволява на <code>whenDepsLoaded</code> да съхранява върнатa стойност от функцията на модула в свойството <code>exports</code> на модула, определя свойството <code>loaded</code> на модула на <em>true</em> и извиква всички функции, които чакат модула да се зареди.</p>
<p><a class="p_ident" id="p_KBR+VgwyVz" href="./10_modules.html#p_KBR+VgwyVz"></a>Този код е много по-труден за следване от <code>require</code> функцията. Неговото изпълнение не следва прост, начертан план. Вместо това, се създават множество операции, които да се случат в някакъв неопределен момент в бъдещето, което замъглява пътя на кода, когато се изпълнява.</p>
<p><a class="p_ident" id="p_uewjoUxlIw" href="./10_modules.html#p_uewjoUxlIw"></a>Истинското изпълнение на AMD, е доста по-интелигентно при разрешаване на имена на модули към действителни URL адреси и като цяло по-стабилно, отколкото това показано по-рано. <em>RequireJS</em> (<a href="http://requirejs.org/"><em>requirejs.org</em></a>) осигурява изпълнението на този популярен стил за модулно зареждане.</p>
<h2><a class="h_ident" id="h_4266RdeHYR" href="./10_modules.html#h_4266RdeHYR"></a>Интерфейс  дизайн</h2>
<p><a class="p_ident" id="p_IUZ7uTWwwd" href="./10_modules.html#p_IUZ7uTWwwd"></a>Проектиране на интерфейси за модули и типове обекти е един от най-фините аспекти на програмирането. Всяко не тривиално парче функционалност може да се моделира по различни начини. Намирането на начин, който работи добре изисква проницателност и далновидност.</p>
<p><a class="p_ident" id="p_KweUtWCb7f" href="./10_modules.html#p_KweUtWCb7f"></a>Най-добрият начин за научаване на добрия дизайн за интерфейс е да се използват много интерфейси, някои добри, някои лоши. Опитът ще ви научи, какво работи и какво не. Никога не допускайте, че трудният интерфейс е “такъв, какъвто е”. Поправете го или го увийте в нов интерфейс, който работи по-добре.</p>
<h3><a class="h_ident" id="h_D19q+FXBVd" href="./10_modules.html#h_D19q+FXBVd"></a>Предвидимост</h3>
<p><a class="p_ident" id="p_2adqTW0fxP" href="./10_modules.html#p_2adqTW0fxP"></a>Ако програмистите могат да прогнозират начина на работа на интерфейса, те (или вие) няма да се отклоняват от целта толкова често при необходимостта да търсят, как да го използват. По този начин се опитват да следват конвенции. Когато има друг модул или част от стандартна JavaScript среда, която прави нещо подобно на това, което се опитвате да приложите, може би е добра идея да направите вашия интерфейс по подобие на съществуващ интерфейс. По този начин, ще се почувствате близки с хора, които знаят за съществуващия интерфейс.</p>
<p><a class="p_ident" id="p_6l6v5cakoT" href="./10_modules.html#p_6l6v5cakoT"></a>Друга област, където предсказуемоста е важна за действителното поведение на вашия код. Може да се изкушите да направите ненужно сложен интерфейс с основанието, че е по-удобен за използване. Например, вие можете да приемете всички видове на различни типове и комбинации от аргументи, за да направите “правилното” нещо за всички тях. Или пък да предоставите десетки специализирани функции, които осигуряват удобство с малко по различен вкус, към функционалноста на модула. Това може да направи кода, на който се основава вашия интерфейс малко по-кратък, но същевременно ще го направи много по-труден за хората, които да изградят по-ясен смислен модел на поведение на модула.</p>
<h3><a class="h_ident" id="h_+NeFt8aXxf" href="./10_modules.html#h_+NeFt8aXxf"></a>Composability</h3>
<p><a class="p_ident" id="p_9Nt/796F0G" href="./10_modules.html#p_9Nt/796F0G"></a>Във вашите интерфейси се опитайте да използвате най-простите структури от данни, ако е възможно и направете вашите функции да правят едно, ясно нещо. Винаги, когато е практично използвайте чисти функции (виж <a href="./03_functions.html#pure">Глава 3</a>).</p>
<p><a class="p_ident" id="p_qicKwwcIoO" href="./10_modules.html#p_qicKwwcIoO"></a>Например, не е необичайно за модули да предоставят свой собствен масив, като обект - колекция, със собствен интерфейс за преброяване и извличане на елементи. Такива обекти нямат <code>map</code> и <code>forEach</code> методи, както и всички съществуващи функции, които очаква истинкия масив и няма да можете да работите с тях. Това е пример за лоша <em>composability</em> (компонентност) - модулът не може да бъде лесно съставен с друг код.</p>
<p><a class="p_ident" id="p_XJefBK7ici" href="./10_modules.html#p_XJefBK7ici"></a>Един пример ще бъде модул за проверка на правописа на текст, който може да ни потрябва, когато искаме да напишем текстов редактор. Проверката на правописа може да се направи да работи директно върху сложни структури от данни с използване на редактор и директно да извиква вътрешните функции на този редактор, за да има потребителя избор между предложения за правописа. Ако вървим по този път, модулът не може да се използва с други програми. От друга страна, ако ние определяме интерфейса за проверка на правописа, така че да можем да го подадем на прост <em>string</em> и той да върне позиция в този <em>string</em>, където е възможно да има правописна грешка, заедно с масив от предложения за корекции, тогава имаме интерфейс, който може да бъде в състава на други системи, защото <em>strings</em> и масиви са винаги на разположение в JavaScript.</p>
<h3><a class="h_ident" id="h_vguoN2JlWc" href="./10_modules.html#h_vguoN2JlWc"></a>Слоеве  от  интерфейси</h3>
<p><a class="p_ident" id="p_gVRzuTdJxo" href="./10_modules.html#p_gVRzuTdJxo"></a>При проектирането на интерфейс за комплексна част от функционалност - например, за изпращане на електронна поща - често ще се сблъсквате с една дилема. От една страна не искате да претоварите потребителя на вашия интерфейс с подробности. Той не трябва да учи вашия интерфейс 20 минути, преди да изпрати имейл. От друга старана, вие не искате да скриете всички детайли, когато хората трябва да правят по-сложни неща с вашия модул, той трябва да бъде в състояние за това.</p>
<p><a class="p_ident" id="p_UAqdlcM0M6" href="./10_modules.html#p_UAqdlcM0M6"></a>Често решението е да се осигурят два интерфейса: един подробен ниско ниво за сложни ситуации и един високо ниво за рутинна употреба. Втория обикновено лесно може да бъде построен с помоща на инструментите предоставени от първия. В модула за поща, интерфейса за високо ниво би могъл да бъде само една функция, с която съобщава адреса на подателя и адреса на получателя  и след това изпраща имейл. Интерфейса за ниско ниво ще позволи пълен контрол над пощата: заглавие, прикачени файлове, HTML поща и т.н.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./10_modules.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_hGwRhRocwV" href="./10_modules.html#p_hGwRhRocwV"></a>Модулите предоставят структура за по-големи програми, чрез отделяне на кода в различни файлове и <em>namespaces</em>. Давайки на тези модули добре дефинирани интерфейси ги прави по-лесни за използване и преизползване и дава възможност да се продължи използването им, когато модулът еволюира.</p>
<p><a class="p_ident" id="p_G2usOklg33" href="./10_modules.html#p_G2usOklg33"></a>Въпреки, че езика на JavaScript е характерно безполезен, когато става въпрос за модули, гъвкавите функции и обекти, които той предоставя дават възможност да се определят по-скоро хубави модулни системи. Обхвата на функциите може да се използва, като вътрешни <em>namespaces</em> за модула, а обектите могат да се използват за съхранение на набора от експортни стойности.</p>
<p><a class="p_ident" id="p_0LAk7BPgRr" href="./10_modules.html#p_0LAk7BPgRr"></a>Има два популярни добре определени подхода към такива модули. Единият се нарича <em>CommonJS Modules</em> и се върти около <code>require</code> функцията, която извлича модул по име и връща интерфейса му. Другата се нарича <em>AMD</em> и използва <code>define</code> функцията, която взема масив с имена на модули и функции, и след като зареди модулите изпълнява функция с техните интерфейси, като аргументи.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./10_modules.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_Ft63zbY95i" href="./10_modules.html#h_Ft63zbY95i"></a>Имената на месеца</h3>
<p><a class="p_ident" id="p_dU0pnoSPR9" href="./10_modules.html#p_dU0pnoSPR9"></a>Напишете прост модул подобен на <code>weekDay</code>, който може да конвертира числата на месеца (с нулева база, като в типа <code>Date</code>) в имена и имената обратно в числа. Дайте му свое собствено <em>namespace</em>, тъй като ще се нуждае от вътрешен масив с имената на месеците и използвайте обикновен JavaScript, без зареждане на модулна система.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_YcMMskAlqo" href="./10_modules.html#c_YcMMskAlqo"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">month</span>.<span class="cm-property">name</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → March</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">month</span>.<span class="cm-property">number</span>(<span class="cm-string">"November"</span>));
<span class="cm-comment">// → 10</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_N564mECTK6" href="./10_modules.html#p_N564mECTK6"></a>Това е почти точно следване на модула <code>weekDay</code>. Функционалния израз извикан веднага, опакова променливата, която държи масива с имената, както и две функции, които трябва да се експортират. Функциите са поставени в един обект и се връщат. Върнатия обект на интерфейса се съхранява в променливата <code>month</code>.</p>
</div></div>
<h3><a class="h_ident" id="h_3j/KaVGNV2" href="./10_modules.html#h_3j/KaVGNV2"></a>Връщане към електронния живот</h3>
<p><a class="p_ident" id="p_+royQ52RxC" href="./10_modules.html#p_+royQ52RxC"></a>Надявам се, че споменът за <a href="./07_elife.html#elife">Chapter 7</a> е още пресен в съзнанието ви, да се върнем обратно към системата проектирана в тази глава и да излезем с начин за разделяне на кода в модули. За да освежим паметта си, това са функциите и типовете, определени в тази глава по реда на появяването им:</p>
<pre>Vector
Grid
directions
directionNames
randomElement
BouncingCritter
elementFromChar
World
charFromElement
Wall
View
WallFollower
dirPlus
LifelikeWorld
Plant
PlantEater
SmartPlantEater
Tiger</pre>
<p><a class="p_ident" id="p_qH0Xj8v2nH" href="./10_modules.html#p_qH0Xj8v2nH"></a>Не преувеличавайте и не създавайте твърде много модули. Една книга, която започва нова глава на всяка страница, вероятно ще ви се качи на нервите, дори и само заради пространството, което губи от новите заглавия. По същия начин, да отваряте 10 файла, за да прочетете един проект, не е полезно. Целта ви е от 3 до 5 модула.</p>
<p><a class="p_ident" id="p_fDzWqQqyw8" href="./10_modules.html#p_fDzWqQqyw8"></a>Можете да определите, някои функции да станат вътрешни за техния модул и по този начин недостъпни за други модули.</p>
<p><a class="p_ident" id="p_XYYo0/YDOl" href="./10_modules.html#p_XYYo0/YDOl"></a>Няма правилен отговор тука. Модулната организация до голяма степен е въпрос на вкус.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_E3iJwXoILn" href="./10_modules.html#p_E3iJwXoILn"></a>Ето какво измислих. Сложил съм скоби около вътрешните функции.</p>
<pre>Module "grid"
  Vector
  Grid
  directions
  directionNames

Module "world"
  (randomElement)
  (elementFromChar)
  (charFromElement)
  View
  World
  LifelikeWorld
  directions [reexported]

Module "simple_ecosystem"
  (randomElement) [duplicated]
  (dirPlus)
  Wall
  BouncingCritter
  WallFollower

Module "ecosystem"
  Wall [duplicated]
  Plant
  PlantEater
  SmartPlantEater
  Tiger</pre>
<p><a class="p_ident" id="p_VwnqNlhTuk" href="./10_modules.html#p_VwnqNlhTuk"></a>Аз имам реекспорт на <code>directions</code> масива от <code>grid</code> модула от <code>world</code>, така че изградените модули на (екосистемата) не трябва да знаят или се притесняват за съществуването на 
<code>grid</code> модул.</p>
<p><a class="p_ident" id="p_2pzeyE24tw" href="./10_modules.html#p_2pzeyE24tw"></a>Също така, дублирам две общи и малки помощни стойности (<code>randomElement</code> and <code>Wall</code>), тъй като те се използват като вътрешна информация в различни контексти и не принадлежат към интерфейсите за тези модули.</p>
</div></div>
<h3><a class="h_ident" id="h_E/zWqBFdy8" href="./10_modules.html#h_E/zWqBFdy8"></a>Кръгови  зависимости</h3>
<p><a class="p_ident" id="p_/LVNV6+2SH" href="./10_modules.html#p_/LVNV6+2SH"></a>Сложна тема в управлението на зависимостите са кръговите зависимости, където модул А зависи от В и В също зависи от А. Много модулни системи просто забраняват това. CommonJS позволява ограничена форма: тя работи толкова дълго с модулите, докато не замени техния <code>exports</code> обект по подразбиране с друга стойност и стартира достъп до всеки друг интерфейс само, след като завърши зареждането.</p>
<p><a class="p_ident" id="p_BFm3QczrDZ" href="./10_modules.html#p_BFm3QczrDZ"></a>Сещате ли се за начин, по който може да се осъществи подръжка за тази функция? Погледнете назад към определението на <code>require</code> и помислете каква функция трябва да направи, за да позволите това.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_By5oQNAE2m" href="./10_modules.html#p_By5oQNAE2m"></a>Номерът е да добавите <code>exports</code> обект, създаден за модул към <code>require</code> кеша, преди действителното стартиране на модула. Това означава, че модула все още не е имал шанс да презапише <code>module.exports</code>, така че ние не знаем дали той може да иска да изнася някаква друга стoйност. След зареждането, кеша на обекта е презаписан от <code>module.exports</code>, който може да бъде различна стойност.</p>
<p><a class="p_ident" id="p_xRLcTfyWjS" href="./10_modules.html#p_xRLcTfyWjS"></a>Но ако в процеса на зареждане на модула е зареден втори модул, той ще пита за първия модул за неговия <code>exports</code> обект по подразбиране, който най-вероятно е празен в този момент и ще бъде в кеша, а втория модул ще получи препратка към него. Ако той не се опита да направи нещо с този обект до завършване на зареждането на първия модул, нещата ще работят.</p>
</div></div>
<nav>
  <a href="./09_regexp.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./11_language.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>